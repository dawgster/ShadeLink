import {base58}from'@scure/base';import _t from'elliptic';import Ft from'js-sha3';import {keccak256,concatHex,numberToHex,getAddress,serializeTransaction,parseTransaction,toBytes,hashMessage,hashTypedData,encodeAbiParameters,hexToBigInt,concat,pad,isAddress}from'viem';import {hashAuthorization}from'viem/experimental';import*as b from'bitcoinjs-lib';import Gt from'coinselect';import {encodeSecp256k1Pubkey}from'@cosmjs/amino';import {sha256,ripemd160}from'@cosmjs/crypto';import {fromHex,toBase64,fromBase64}from'@cosmjs/encoding';import {Registry,encodePubkey,makeAuthInfoBytes,makeSignDoc,makeSignBytes}from'@cosmjs/proto-signing';import {calculateFee,GasPrice,StargateClient}from'@cosmjs/stargate';import {bech32}from'bech32';import {SignMode}from'cosmjs-types/cosmos/tx/signing/v1beta1/signing';import {TxRaw}from'cosmjs-types/cosmos/tx/v1beta1/tx';import {chains,assets}from'chain-registry';import {PublicKey,Transaction,SystemProgram}from'@solana/web3.js';import {Ed25519PublicKey,Deserializer,MultiAgentTransaction,SimpleTransaction,generateSigningMessageForTransaction,AccountAuthenticatorEd25519,Ed25519Signature,generateSignedTransaction,SignedTransaction,postAptosFullNode,MimeType,KeylessPublicKey,FederatedKeylessPublicKey,AbstractKeylessAccount}from'@aptos-labs/ts-sdk';import xe from'bs58';import {toBase64 as toBase64$1}from'@mysten/bcs';import {SuiHTTPTransport}from'@mysten/sui/client';import {messageWithIntent,toSerializedSignature}from'@mysten/sui/cryptography';import {Ed25519PublicKey as Ed25519PublicKey$1}from'@mysten/sui/keypairs/ed25519';import {blake2b}from'@noble/hashes/blake2b';import {createHash}from'node:crypto';import {encodeAccountID}from'ripple-address-codec';import {encode}from'ripple-binary-codec';import {Client}from'xrpl';import {encodeTransaction,Transaction as Transaction$1,Action,Transfer,createTransaction,SignedTransaction as SignedTransaction$1,Signature,CreateAccount,AddKey,AccessKey,AccessKeyPermission,FullAccessPermission,actionCreators}from'@near-js/transactions';import {PublicKey as PublicKey$1}from'@near-js/crypto';import {baseDecode,getTransactionLastResult}from'@near-js/utils';import {JsonRpcProvider,FailoverRpcProvider}from'@near-js/providers';var It=Object.defineProperty;var l=(s,t)=>{for(var e in t)It(s,e,{get:t[e],enumerable:true});};var ut={};l(ut,{CHAINS:()=>v,CONTRACT_ADDRESSES:()=>kt,ENVS:()=>m,KDF_CHAIN_IDS:()=>R,ROOT_PUBLIC_KEYS:()=>Nt});var m={TESTNET_DEV:"TESTNET_DEV",TESTNET:"TESTNET",MAINNET:"MAINNET"},v={ETHEREUM:"ETHEREUM",NEAR:"NEAR"},Nt={[m.TESTNET_DEV]:"secp256k1:54hU5wcCmVUPFWLDALXMh1fFToZsVXrx9BbTbHzSfQq1Kd1rJZi52iPa4QQxo6s5TgjWqgpY8HamYuUDzG6fAaUq",[m.TESTNET]:"secp256k1:3Ww8iFjqTHufye5aRGUvrQqETegR4gVUcW8FX5xzscaN9ENhpkffojsxJwi6N1RbbHMTxYa9UyKeqK3fsMuwxjR5",[m.MAINNET]:"secp256k1:4tY4qMzusmgX5wYdG35663Y3Qar3CTbpApotwk9ZKLoF79XA4DjG8XoByaKdNHKQX9Lz5hd7iJqsWdTKyA7dKa6Z"},R={[v.ETHEREUM]:"0x1",[v.NEAR]:"0x18d"},kt={[v.NEAR]:{[m.TESTNET_DEV]:"dev.sig-net.testnet",[m.TESTNET]:"v1.sig-net.testnet",[m.MAINNET]:"v1.sig-net.near"},[v.ETHEREUM]:{[m.TESTNET_DEV]:"0x69C6b28Fdc74618817fa380De29a653060e14009",[m.TESTNET]:"0x83458E8Bf8206131Fe5c05127007FA164c0948A2",[m.MAINNET]:"0xf8bdC0612361a1E49a8E01423d4C0cFc5dF4791A"}};var pt={};l(pt,{cryptography:()=>y});var y={};l(y,{compressPubKey:()=>zt,deriveChildPublicKey:()=>Dt,najToUncompressedPubKeySEC1:()=>I,toRSV:()=>Ht,uint8ArrayToHex:()=>L});var Ht=s=>{if("big_r"in s&&typeof s.big_r=="object"&&"affine_point"in s.big_r&&"s"in s&&typeof s.s=="object"&&"scalar"in s.s)return {r:s.big_r.affine_point.substring(2),s:s.s.scalar,v:s.recovery_id+27};if("big_r"in s&&typeof s.big_r=="string"&&"s"in s&&typeof s.s=="string")return {r:s.big_r.substring(2),s:s.s,v:s.recovery_id+27};if("bigR"in s&&"x"in s.bigR&&"s"in s&&typeof s.s=="bigint")return {r:s.bigR.x.toString(16).padStart(64,"0"),s:s.s.toString(16).padStart(64,"0"),v:s.recoveryId+27};throw new Error("Invalid signature format")},zt=s=>{let t=s.slice(2);if(t.length!==128)throw new Error("Invalid uncompressed public key length");let e=t.slice(0,64),n=t.slice(64);return (parseInt(n.slice(-1),16)%2===0?"02":"03")+e},I=s=>{let t=base58.decode(s.split(":")[1]);return `04${Buffer.from(t).toString("hex")}`};function Dt(s,t,e="",n){let r=new _t.ec("secp256k1"),i=`sig.network v1.0.0 epsilon derivation,${n},${t},${e}`,o="";if(n===R.ETHEREUM)o=keccak256(Buffer.from(i)).slice(2);else if(n===R.NEAR)o=Ft.sha3_256(i);else throw new Error("Invalid chain ID");let d=s.substring(2,66),c=s.substring(66),u=r.curve.point(d,c),g=r.g.mul(o),f=u.add(g),h=f.getX().toString("hex").padStart(64,"0"),S=f.getY().toString("hex").padStart(64,"0");return `04${h}${S}`}var L=s=>Array.from(s).map(t=>t.toString(16).padStart(2,"0")).join("");var Kt={};l(Kt,{ChainAdapter:()=>p,aptos:()=>Z,btc:()=>j,cosmos:()=>J,evm:()=>q,near:()=>it,solana:()=>Y,sui:()=>et,xrp:()=>rt});var p=class{};var q={};l(q,{EVM:()=>V,fetchEVMFeeProperties:()=>N});async function N(s,t){let e=t.gas?Promise.resolve(t.gas):s.estimateGas({account:t.from,...t}),n=t.maxFeePerGas&&t.maxPriorityFeePerGas?Promise.resolve({maxFeePerGas:t.maxFeePerGas,maxPriorityFeePerGas:t.maxPriorityFeePerGas}):s.estimateFeesPerGas(),[r,a]=await Promise.all([e,n]),i=a.maxFeePerGas??BigInt(1e10),o=a.maxPriorityFeePerGas??BigInt(1e10);return {gas:r,maxFeePerGas:i,maxPriorityFeePerGas:o}}var V=class extends p{constructor({publicClient:t,contract:e}){super(),this.contract=e,this.client=t;}async attachGasAndNonce(t){let e=await N(this.client,t),n=t.nonce??await this.client.getTransactionCount({address:t.from}),{from:r,...a}=t;return {...e,nonce:n,chainId:Number(await this.client.getChainId()),type:"eip1559",...a}}async attachGasAndNonceLegacy(t){let e=t.gasPrice??await this.client.getGasPrice(),n=t.nonce??await this.client.getTransactionCount({address:t.from}),{from:r,...a}=t;return {...a,gasPrice:BigInt(e),nonce:Number(n),value:a.value!==void 0?BigInt(a.value):void 0,gas:a.gas!==void 0?BigInt(a.gas):BigInt(21e3),chainId:await this.client.getChainId(),type:"legacy"}}transformRSVSignature(t){return {r:`0x${t.r}`,s:`0x${t.s}`,yParity:t.v-27}}assembleSignature(t){let{r:e,s:n,yParity:r}=this.transformRSVSignature(t);if(r===void 0)throw new Error("Missing yParity");return concatHex([e,n,numberToHex(r+27,{size:1})])}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let r=n.startsWith("04")?n.slice(2):n,a=keccak256(Buffer.from(r,"hex"));return {address:getAddress(`0x${a.slice(-40)}`),publicKey:n}}async getBalance(t){return {balance:await this.client.getBalance({address:t}),decimals:18}}serializeTransaction(t){return serializeTransaction(t)}deserializeTransaction(t){return parseTransaction(t)}async prepareTransactionForSigning(t){let e=await this.attachGasAndNonce(t),n=serializeTransaction(e),r=toBytes(keccak256(n));return {transaction:e,hashesToSign:[Array.from(r)]}}async prepareTransactionForSigningLegacy(t){let e=await this.attachGasAndNonceLegacy(t),n=serializeTransaction(e),r=toBytes(keccak256(n));return {transaction:e,hashesToSign:[Array.from(r)]}}async prepareMessageForSigning(t){return {hashToSign:Array.from(toBytes(hashMessage(t)))}}async prepareTypedDataForSigning(t){return {hashToSign:Array.from(toBytes(hashTypedData(t)))}}async prepareUserOpForSigning(t,e,n){let r=n??await this.client.getChainId(),a=e||"0x0000000071727De22E5E9d8BAf0edAc6f37da032",i=encodeAbiParameters([{type:"bytes32"},{type:"address"},{type:"uint256"}],[keccak256(encodeAbiParameters([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"}],[t.sender,hexToBigInt(t.nonce),keccak256("factory"in t&&"factoryData"in t&&t.factory&&t.factoryData?concat([t.factory,t.factoryData]):"initCode"in t?t.initCode:"0x"),keccak256(t.callData),concat([pad(t.verificationGasLimit,{size:16}),pad(t.callGasLimit,{size:16})]),hexToBigInt(t.preVerificationGas),concat([pad(t.maxPriorityFeePerGas,{size:16}),pad(t.maxFeePerGas,{size:16})]),keccak256("paymaster"in t&&t.paymaster&&isAddress(t.paymaster)?concat([t.paymaster,pad(t.paymasterVerificationGasLimit,{size:16}),pad(t.paymasterPostOpGasLimit,{size:16}),t.paymasterData]):"paymasterAndData"in t?t.paymasterAndData:"0x")])),a,BigInt(r)]),o=keccak256(i);return {userOp:t,hashToSign:Array.from(toBytes(hashMessage({raw:o})))}}prepareAuthorizationForSigning(t){let e=t.contractAddress??t.address;return {hashToSign:Array.from(toBytes(hashAuthorization({address:e,chainId:t.chainId,nonce:t.nonce})))}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){let n=this.transformRSVSignature(e[0]);return serializeTransaction(t,n)}finalizeTransactionSigningLegacy({transaction:t,rsvSignatures:e}){let n={v:BigInt(e[0].v),r:`0x${e[0].r.padStart(64,"0")}`,s:`0x${e[0].s.padStart(64,"0")}`,yParity:e[0].v-27};return serializeTransaction(t,n)}finalizeMessageSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeTypedDataSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeUserOpSigning({userOp:t,rsvSignature:e}){let{r:n,s:r,yParity:a}=this.transformRSVSignature(e);if(a===void 0)throw new Error("Missing yParity");return {...t,signature:concatHex(["0x00",n,r,numberToHex(Number(a+27),{size:1})])}}finalizeAuthorizationSigning(t){return {address:t.authorization.contractAddress??t.authorization.address,chainId:t.authorization.chainId,nonce:t.authorization.nonce,...this.transformRSVSignature(t.rsvSignature)}}async broadcastTx(t){try{return {hash:await this.client.sendRawTransaction({serializedTransaction:t})}}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var j={};l(j,{BTCRpcAdapter:()=>x,BTCRpcAdapters:()=>ht,Bitcoin:()=>F,Mempool:()=>w});function G(s){switch(s.toLowerCase()){case "mainnet":return b.networks.bitcoin;case "testnet":return b.networks.testnet;case "regtest":return b.networks.regtest;default:throw new Error(`Unknown Bitcoin network: ${s}`)}}var F=class s extends p{static{this.SATOSHIS_PER_BTC=1e8;}constructor({network:t,contract:e,btcRpcAdapter:n}){super(),this.network=t,this.btcRpcAdapter=n,this.contract=e;}static toBTC(t){return t/s.SATOSHIS_PER_BTC}static toSatoshi(t){return Math.round(t*s.SATOSHIS_PER_BTC)}async fetchTransaction(t){let e=await this.btcRpcAdapter.getTransaction(t),n=new b.Transaction;return e.vout.forEach(r=>{let a=Buffer.from(r.scriptpubkey,"hex");n.addOutput(a,Number(r.value));}),n}static transformRSVSignature(t){let e=t.r.padStart(64,"0"),n=t.s.padStart(64,"0"),r=Buffer.from(e+n,"hex");if(r.length!==64)throw new Error("Invalid signature length.");return r}async createPSBT({transactionRequest:t}){let{inputs:e,outputs:n}=t.inputs&&t.outputs?t:await this.btcRpcAdapter.selectUTXOs(t.from,[{address:t.to,value:parseFloat(t.value)}]),r=new b.Psbt({network:G(this.network)});return await Promise.all(e.map(async a=>{if(!a.scriptPubKey){let o=(await this.fetchTransaction(a.txid)).outs[a.vout];a.scriptPubKey=o.script;}r.addInput({hash:a.txid,index:a.vout,witnessUtxo:{script:a.scriptPubKey,value:a.value}});})),n.forEach(a=>{"address"in a?r.addOutput({address:a.address,value:a.value}):"script"in a?r.addOutput({script:a.script,value:a.value}):t.from!==void 0&&r.addOutput({value:Number(a.value),address:t.from});}),r}async getBalance(t){return {balance:BigInt(await this.btcRpcAdapter.getBalance(t)),decimals:8}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let r=y.compressPubKey(n),a=Buffer.from(r,"hex"),i=G(this.network),o=b.payments.p2wpkh({pubkey:a,network:i}),{address:d}=o;if(!d)throw new Error("Failed to generate Bitcoin address");return {address:d,publicKey:r}}serializeTransaction(t){return JSON.stringify({psbt:t.psbt.toHex(),publicKey:t.publicKey})}deserializeTransaction(t){let e=JSON.parse(t);return {psbt:b.Psbt.fromHex(e.psbt),publicKey:e.publicKey}}async prepareTransactionForSigning(t){let e=Buffer.from(t.publicKey,"hex"),n=await this.createPSBT({transactionRequest:t}),r=n.toHex(),a=[],i=o=>({publicKey:e,sign:d=>(a[o]=Array.from(d),Buffer.alloc(64))});for(let o=0;o<n.inputCount;o++)n.signInput(o,i(o));return {transaction:{psbt:b.Psbt.fromHex(r),publicKey:t.publicKey},hashesToSign:a}}finalizeTransactionSigning({transaction:{psbt:t,publicKey:e},rsvSignatures:n}){let r=Buffer.from(e,"hex"),a=i=>({publicKey:r,sign:()=>{let o=n[i];return s.transformRSVSignature(o)}});for(let i=0;i<t.inputCount;i++)t.signInput(i,a(i));return t.finalizeAllInputs(),t.extractTransaction().toHex()}async broadcastTx(t){return {hash:await this.btcRpcAdapter.broadcastTransaction(t)}}};var x=class{};var w=class extends x{constructor(t){super(),this.providerUrl=t;}async fetchFeeRate(t=6){let n=await(await fetch(`${this.providerUrl}/v1/fees/recommended`)).json();return t<=1?n.fastestFee:t<=3?n.halfHourFee:t<=6?n.hourFee:n.economyFee}async fetchUTXOs(t){try{return await(await fetch(`${this.providerUrl}/address/${t}/utxo`)).json()}catch(e){return console.error("Failed to fetch UTXOs:",e),[]}}async selectUTXOs(t,e,n=6){let r=await this.fetchUTXOs(t),a=await this.fetchFeeRate(n),i=Gt(r,e,Math.ceil(a+1));if(!i.inputs||!i.outputs)throw new Error("Invalid transaction: coinselect failed to find a suitable set of inputs and outputs. This could be due to insufficient funds, or no inputs being available that meet the criteria.");return {inputs:i.inputs,outputs:i.outputs}}async broadcastTransaction(t){let e=await fetch(`${this.providerUrl}/tx`,{method:"POST",body:t});if(e.ok)return await e.text();throw new Error(`Failed to broadcast transaction: ${await e.text()}`)}async getBalance(t){let n=await(await fetch(`${this.providerUrl}/address/${t}`)).json();return n.chain_stats.funded_txo_sum-n.chain_stats.spent_txo_sum}async getTransaction(t){return await(await fetch(`${this.providerUrl}/tx/${t}`)).json()}};var ht={Mempool:w};var J={};l(J,{Cosmos:()=>H});var Tt=async s=>{let t=chains.find(g=>g.chain_id===s);if(!t)throw new Error(`Chain info not found for chainId: ${s}`);let{bech32_prefix:e,chain_id:n}=t,r=t.staking?.staking_tokens?.[0]?.denom,a=t.apis?.rpc?.[0]?.address,i=t.apis?.rest?.[0]?.address,o=t.fees?.fee_tokens?.[0]?.average_gas_price;if(!e||!r||!a||!i||!n||o===void 0)throw new Error(`Missing required chain information for ${t.chain_name}`);let c=assets.find(g=>g.chain_name===t.chain_name)?.assets.find(g=>g.base===r),u=c?.denom_units.find(g=>g.denom===c.display)?.exponent;if(u===void 0)throw new Error(`Could not find decimals for ${r} on chain ${t.chain_name}`);return {prefix:e,denom:r,rpcUrl:a,restUrl:i,expectedChainId:n,gasPrice:o,decimals:u}};var H=class extends p{constructor({chainId:t,contract:e,endpoints:n}){super(),this.contract=e,this.registry=new Registry,this.chainId=t,this.endpoints=n;}transformRSVSignature(t){return new Uint8Array([...fromHex(t.r),...fromHex(t.s)])}async getChainInfo(){return {...await Tt(this.chainId),...this.endpoints}}async getBalance(t){try{let{restUrl:e,denom:n,decimals:r}=await this.getChainInfo(),a=await fetch(`${e}/cosmos/bank/v1beta1/balances/${t}`);if(!a.ok)throw new Error(`HTTP error! status: ${a.status}`);let d=(await a.json()).balances.find(c=>c.denom===n)?.amount??"0";return {balance:BigInt(d),decimals:r}}catch(e){throw console.error("Failed to fetch Cosmos balance:",e),new Error("Failed to fetch Cosmos balance")}}async deriveAddressAndPublicKey(t,e){let{prefix:n}=await this.getChainInfo(),r=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!r)throw new Error("Failed to get derived public key");let a=y.compressPubKey(r),i=sha256(fromHex(a)),o=ripemd160(i);return {address:bech32.encode(n,bech32.toWords(o)),publicKey:a}}serializeTransaction(t){let e=TxRaw.encode(t).finish();return toBase64(e)}deserializeTransaction(t){return TxRaw.decode(fromBase64(t))}async prepareTransactionForSigning(t){let{denom:e,rpcUrl:n,gasPrice:r}=await this.getChainInfo(),a=fromHex(t.publicKey),i=t.gas||2e5,o=calculateFee(i,GasPrice.fromString(`${r}${e}`)),c=await(await StargateClient.connect(n)).getAccount(t.address);if(!c)throw new Error(`Account ${t.address} does not exist on chain`);let{accountNumber:u,sequence:g}=c,f={typeUrl:"/cosmos.tx.v1beta1.TxBody",value:{messages:t.messages,memo:t.memo||""}},h=this.registry.encode(f),S=encodePubkey(encodeSecp256k1Pubkey(a)),P=makeAuthInfoBytes([{pubkey:S,sequence:g}],o.amount,Number(o.gas),void 0,void 0,SignMode.SIGN_MODE_DIRECT),O=makeSignDoc(h,P,this.chainId,u),X=makeSignBytes(O),B=Array.from(sha256(X));return {transaction:TxRaw.fromPartial({bodyBytes:h,authInfoBytes:P,signatures:[]}),hashesToSign:[B]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){t.signatures=e.map(r=>this.transformRSVSignature(r));let n=TxRaw.encode(t).finish();return Buffer.from(n).toString("hex")}async broadcastTx(t){try{let{rpcUrl:e}=await this.getChainInfo(),n=await StargateClient.connect(e),r=fromHex(t),a=await n.broadcastTx(r);if(a.code!==0)throw new Error(`Broadcast error: ${a.rawLog}`);return a.transactionHash}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var Y={};l(Y,{Solana:()=>W});var de=s=>typeof s=="bigint"?s:BigInt(s.toString()),W=class extends p{constructor(t){super(),this.connection=t.solanaConnection,this.contract=t.contract;}async getBalance(t){let e=new PublicKey(t),n=await this.connection.getBalance(e);return {balance:BigInt(n),decimals:9}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true});console.log("[chainsig.js] getDerivedPublicKey returned:",n);let r=n.replace("ed25519:","");console.log("[chainsig.js] after replace, base58Key:",r);let a=new PublicKey(r);return {address:a.toBase58(),publicKey:a.toString()}}serializeTransaction(t){return Buffer.from(t.transaction.serialize({requireAllSignatures:false})).toString("base64")}deserializeTransaction(t){let e=Buffer.from(t,"base64"),n=Transaction.from(e);return {transaction:n,feePayer:n.feePayer||new PublicKey("11111111111111111111111111111111"),recentBlockhash:n.recentBlockhash||""}}async prepareTransactionForSigning(t){let e=new Transaction,n=de(t.amount);n>0n&&e.add(SystemProgram.transfer({fromPubkey:new PublicKey(t.from),toPubkey:new PublicKey(t.to),lamports:Number(n)})),t.instructions&&e.add(...t.instructions);let{blockhash:r}=await this.connection.getLatestBlockhash();e.recentBlockhash=r,e.feePayer=t.feePayer||new PublicKey(t.from);let a=e.compileMessage().serialize();return {transaction:{transaction:e,feePayer:e.feePayer,recentBlockhash:r},hashesToSign:[Array.from(a)]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e,senderAddress:n}){let r=Buffer.from(e.signature);return t.addSignature(new PublicKey(n),r),t.serialize().toString("base64")}async broadcastTx(t){let e=this.deserializeTransaction(t);return {hash:await this.connection.sendRawTransaction(e.transaction.serialize())}}};var Z={};l(Z,{Aptos:()=>z});var z=class extends p{constructor({contract:t,client:e}){super(),this.contract=t,this.client=e;}async getBalance(t){let e=await this.client.account.getAccountAPTAmount({accountAddress:t});return {balance:BigInt(e),decimals:8}}async deriveAddressAndPublicKey(t,e){let r=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),a=xe.decode(r),i="0x"+Buffer.from(a).toString("hex");return {address:new Ed25519PublicKey(a).authKey().derivedAddress().toString(),publicKey:i}}serializeTransaction(t){return t.bcsToHex().toString()}deserializeTransaction(t){let e=t.startsWith("0x"),n=Buffer.from(e?t.slice(2):t,"hex");try{let a=new Deserializer(n);return MultiAgentTransaction.deserialize(a)}catch{}let r=new Deserializer(n);return SimpleTransaction.deserialize(r)}async prepareTransactionForSigning(t){return {transaction:t,hashesToSign:[generateSigningMessageForTransaction(t)]}}rsvSignatureToSenderAuthenticator(t){let e=Buffer.from(t.rsvSignatures.signature),n=t.publicKey.startsWith("0x"),r=Buffer.from(n?t.publicKey.slice(2):t.publicKey,"hex"),a=new Ed25519PublicKey(r);return new AccountAuthenticatorEd25519(a,new Ed25519Signature(e.toString("hex")))}finalizeTransactionSigning(t){let e=this.rsvSignatureToSenderAuthenticator({rsvSignatures:t.rsvSignatures,publicKey:t.publicKey}),n=generateSignedTransaction({transaction:t.transaction,senderAuthenticator:e,additionalSignersAuthenticators:t.additionalSignersAuthenticators,feePayerAuthenticator:t.feePayerAuthenticator});return "0x"+Buffer.from(n).toString("hex")}deserializeSignedTransaction(t){let e=t.startsWith("0x"),n=Buffer.from(e?t.slice(2):t,"hex"),r=new Deserializer(n);return SignedTransaction.deserialize(r)}async broadcastTx(t){let e=this.deserializeSignedTransaction(t);try{let{data:n}=await postAptosFullNode({aptosConfig:this.client.config,body:e.bcsToBytes(),path:"transactions",originMethod:"submitTransaction",contentType:MimeType.BCS_SIGNED_TRANSACTION});return {hash:n.hash}}catch(n){throw e.authenticator.isSingleSender()&&e.authenticator.sender.isSingleKey()&&(e.authenticator.sender.public_key.publicKey instanceof KeylessPublicKey||e.authenticator.sender.public_key.publicKey instanceof FederatedKeylessPublicKey)&&await AbstractKeylessAccount.fetchJWK({aptosConfig:this.client.config,publicKey:e.authenticator.sender.public_key.publicKey,kid:e.authenticator.sender.signature.signature.getJwkKid()}),n}}};var et={};l(et,{SUI:()=>tt});var tt=class extends p{constructor({contract:t,client:e,rpcUrl:n}){super(),this.contract=t,this.client=e,this.transport=new SuiHTTPTransport({url:n});}async getBalance(t){let e=await this.client.getBalance({owner:t});return {balance:BigInt(e.totalBalance),decimals:9}}async deriveAddressAndPublicKey(t,e){let r=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),a=xe.decode(r),i=new Ed25519PublicKey$1(a);return {publicKey:i.toSuiPublicKey(),address:i.toSuiAddress()}}serializeTransaction(t){return Buffer.from(t).toString("hex")}deserializeTransaction(t){let e=Buffer.from(t,"hex");return new Uint8Array(e)}async prepareTransactionForSigning(t){let e=await t.build({client:this.client}),r=messageWithIntent("TransactionData",e);return {hashesToSign:[blake2b(r,{dkLen:32})],transaction:e}}rsvSignatureToSuiSignature(t){let n=Buffer.from(t.publicKey,"base64").subarray(1);return toSerializedSignature({signature:Buffer.from(t.rsvSignatures.signature),signatureScheme:"ED25519",publicKey:new Ed25519PublicKey$1(n)})}finalizeTransactionSigning(t){let e=this.rsvSignatureToSuiSignature(t);return JSON.stringify([typeof t.transaction=="string"?t.transaction:toBase64$1(t.transaction),Array.isArray(e)?e:[e]])}async broadcastTx(t){return {hash:(await this.transport.request({method:"sui_executeTransactionBlock",params:JSON.parse(t)})).digest}}};var rt={};l(rt,{XRP:()=>D});var D=class extends p{constructor({rpcUrl:t,contract:e,client:n}){super(),this.rpcUrl=t,this.contract=e,this.client=n||new Client(this.rpcUrl);}async getBalance(t){try{await this.client.connect();let e=await this.client.request({command:"account_info",account:t,ledger_index:"validated"});return {balance:BigInt(String(e?.result?.account_data?.Balance))||0n,decimals:6}}catch(e){if(e?.data?.error==="actNotFound"||e?.message?.includes("Account not found")||e?.data?.error_message?.includes("Account not found"))return {balance:0n,decimals:6};throw console.error("Failed to fetch XRP balance:",e),new Error("Failed to fetch XRP balance")}finally{try{await this.client.disconnect();}catch(e){console.warn("Error disconnecting XRP client:",e);}}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived secp256k1 public key");let r=y.compressPubKey(n);return {address:this.deriveXRPAddress(r),publicKey:r}}deriveXRPAddress(t){let e=Buffer.from(t,"hex"),n=createHash("sha256").update(e).digest(),r=createHash("ripemd160").update(n).digest();return encodeAccountID(r)}serializeTransaction(t){return JSON.stringify(t)}deserializeTransaction(t){return JSON.parse(t)}async prepareTransactionForSigning(t){try{await this.client.connect();let e=t.publicKey,n=await this.client.autofill({TransactionType:"Payment",Account:t.from,Destination:t.to,Amount:t.amount,SigningPubKey:e.toUpperCase()}),r={transaction:n,signingPubKey:e},a=encode(n),i=new Uint8Array([83,84,88,0]),o=new Uint8Array(Buffer.from(a,"hex")),d=new Uint8Array(i.length+o.length);d.set(i,0),d.set(o,i.length);let c=createHash("sha512").update(d).digest(),u=new Uint8Array(c.subarray(0,32));return {transaction:r,hashesToSign:[u]}}catch(e){throw console.error("Failed to prepare XRP transaction for signing:",e),new Error("Failed to prepare XRP transaction for signing")}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){if(e.length===0)throw new Error("Invalid signatures provided");let n=e[0],r=this.generateTxnSignature(n.r,n.s,n.v),a={...t.transaction,TxnSignature:r,SigningPubKey:t.signingPubKey.toUpperCase()};return JSON.stringify(a)}generateTxnSignature(t,e,n){let r=Buffer.from(t,"hex"),a=Buffer.from(e,"hex"),i=r;r[0]>127&&(i=Buffer.concat([Buffer.from([0]),r]));let o=a;a[0]>127&&(o=Buffer.concat([Buffer.from([0]),a]));let d=2+i.length+2+o.length,c=Buffer.alloc(2+d),u=0;return c.writeUInt8(48,u++),c.writeUInt8(d,u++),c.writeUInt8(2,u++),c.writeUInt8(i.length,u++),i.copy(c,u),u+=i.length,c.writeUInt8(2,u++),c.writeUInt8(o.length,u++),o.copy(c,u),c.toString("hex").toUpperCase()}async broadcastTx(t){try{await this.client.connect();let e=JSON.parse(t),n=encode(e),r=await this.client.submit(n);if(await this.client.disconnect(),r.result.engine_result==="tesSUCCESS"||r.result.engine_result==="terQUEUED"){let a=r.result.tx_json?.hash;if(!a)throw new Error("Transaction submitted but no hash received");return {hash:a}}else throw new Error(`Transaction failed: ${r.result.engine_result} - ${r.result.engine_result==="terQUEUED"?"Transaction is queued":r.result.engine_result}`)}catch(e){throw console.error("Failed to broadcast XRP transaction:",e),new Error("Failed to broadcast XRP transaction")}}};var it={};l(it,{NEAR:()=>$,utils:()=>st});var Me=async s=>{let t=globalThis.crypto;if(t&&t.subtle){let n=await t.subtle.digest("SHA-256",s);return new Uint8Array(n)}let{createHash:e}=await import('node:crypto');return new Uint8Array(e("sha256").update(s).digest())},$=class extends p{constructor(t){super(),this.provider=new JsonRpcProvider({url:t.rpcUrl}),this.contract=t.contract,this.networkId=t.networkId;}isAccountDoesNotExistError(t){let e=t?.message?.toString?.()||"";return (t?.type?.toString?.()||"")==="AccountDoesNotExist"||e.includes("AccountDoesNotExist")||e.includes("doesn't exist")||e.includes("does not exist")}async getBalance(t){try{let e=await this.provider.query(`account/${t}`,"");return {balance:BigInt(e.amount),decimals:24}}catch(e){throw this.isAccountDoesNotExistError(e)?new Error(`NEAR derived account not found: ${t}. Create & fund it or call chainAdapters.near.utils.ensureDerivedAccountExists(...) before sending.`):e}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true}),r=PublicKey$1.fromString(n);return {address:`${e}.${t}`,publicKey:r.toString()}}serializeTransaction(t){let e=encodeTransaction(t.transaction);return Buffer.from(e).toString("base64")}deserializeTransaction(t){let e=Buffer.from(t,"base64");return {transaction:Transaction$1.decode(e)}}async prepareTransactionForSigning(t){let{from:e,to:n,amount:r,publicKey:a}=t,i;try{i=await this.provider.query(`access_key/${e}/${a}`,"");}catch(P){throw this.isAccountDoesNotExistError(P)?new Error(`NEAR derived account not found: ${e}. Create & fund it or call chainAdapters.near.utils.ensureDerivedAccountExists({ derivedAccountId: "${e}", mpcPublicKey: "${a}" }).`):P}let o=await this.provider.block({finality:"final"}),d=baseDecode(i?.block_hash??o.header.hash),c=PublicKey$1.fromString(i?.public_key?i.public_key:a),u=i?.nonce?i.nonce+1:1,g=[new Action({transfer:new Transfer({deposit:BigInt(r)})})],f=createTransaction(e,c,n,u,g,d),h=encodeTransaction(f),S=await Me(h);return {transaction:{transaction:f},hashesToSign:[Array.from(S)]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){if(Array.isArray(e))throw new Error("NEAR expects an Ed25519 signature object, not RSV array");let n=Buffer.from(e.signature),r="transaction"in t?t.transaction:t,i=new SignedTransaction$1({transaction:r,signature:new Signature({keyType:r.publicKey.keyType,data:n})}).encode();return Buffer.from(i).toString("base64")}async broadcastTx(t){let e=Buffer.from(t,"base64"),n=SignedTransaction$1.decode(e);return {hash:(await this.provider.sendTransaction(n)).transaction.hash}}};var st={};l(st,{ensureDerivedAccountExists:()=>Qe});async function Qe(s){let{provider:t,controllerAccountId:e,controllerKeyPair:n,derivedAccountId:r,mpcPublicKey:a,initialDepositYocto:i}=s;try{let B=await t.query(`account/${r}`,"");if(B&&typeof B.amount=="string")return {created:!1}}catch{}let o=n.getPublicKey(),d=await t.query(`access_key/${e}/${o.toString()}`,""),c=baseDecode(d.block_hash),u=BigInt((d.nonce??0)+1),g=PublicKey$1.fromString(a),f=[new Action({createAccount:new CreateAccount}),new Action({transfer:new Transfer({deposit:i})}),new Action({addKey:new AddKey({publicKey:g,accessKey:new AccessKey({nonce:0n,permission:new AccessKeyPermission({fullAccess:new FullAccessPermission})})})})],h=new Transaction$1({signerId:e,publicKey:o,nonce:u,receiverId:r,actions:f,blockHash:c}),S=encodeTransaction(h),P=createHash("sha256").update(S).digest(),O=n.sign(P),X=new SignedTransaction$1({transaction:h,signature:new Signature({keyType:o.keyType,data:O.signature})});return await t.sendTransaction(X),{created:true}}var Rt={};l(Rt,{ChainSignatureContract:()=>dt,utils:()=>rn});var ct={};l(ct,{responseToMpcSignature:()=>ot});var ot=({signature:s})=>{if("scheme"in s&&s.scheme==="Ed25519"&&"signature"in s)return s;if(s)return y.toRSV(s)};var Ut="300000000000000";var dt=class{constructor({contractId:t,networkId:e,fallbackRpcUrls:n}){this.contractId=t,this.networkId=e;let r=n&&n.length>0?n:[`https://rpc.${this.networkId}.near.org`];this.provider=new FailoverRpcProvider(r.map(a=>new JsonRpcProvider({url:a})));}getCurrentSignatureDeposit(){return 1}async sign({payloads:t,path:e,keyType:n,signerAccount:r}){let a=t.map(c=>({signerId:r.accountId,receiverId:this.contractId,actions:[actionCreators.functionCall("sign",{request:{payload_v2:{[n]:L(c)},path:e,domain_id:n==="Eddsa"?1:0}},BigInt(Ut),BigInt(1))]}));return (await r.signAndSendTransactions({transactions:a})).map(c=>getTransactionLastResult(c)).map(c=>ot({signature:c}))}async getPublicKey(){let t=await this.provider.callFunction(this.contractId,"public_key",{});return I(t)}async getDerivedPublicKey(t){let e=await this.provider.callFunction(this.contractId,"derived_public_key",{path:t.path,predecessor:t.predecessor,domain_id:t.IsEd25519?1:0});return t.IsEd25519?e:I(e)}};var rn={transaction:ct};
export{Kt as chainAdapters,ut as constants,Rt as contracts,pt as utils};//# sourceMappingURL=index.browser.js.map
//# sourceMappingURL=index.browser.js.map