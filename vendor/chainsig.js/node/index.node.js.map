{"version":3,"sources":["../../src/constants.ts","../../src/utils/index.ts","../../src/utils/cryptography.ts","../../src/chain-adapters/index.ts","../../src/chain-adapters/ChainAdapter.ts","../../src/chain-adapters/EVM/index.ts","../../src/chain-adapters/EVM/EVM.ts","../../src/chain-adapters/EVM/utils.ts","../../src/chain-adapters/Bitcoin/index.ts","../../src/chain-adapters/Bitcoin/utils.ts","../../src/chain-adapters/Bitcoin/Bitcoin.ts","../../src/chain-adapters/Bitcoin/BTCRpcAdapter/BTCRpcAdapter.ts","../../src/chain-adapters/Bitcoin/BTCRpcAdapter/Mempool/Mempool.ts","../../src/chain-adapters/Bitcoin/BTCRpcAdapter/index.ts","../../src/chain-adapters/Cosmos/index.ts","../../src/chain-adapters/Cosmos/Cosmos.ts","../../src/chain-adapters/Cosmos/utils.ts","../../src/chain-adapters/Solana/index.ts","../../src/chain-adapters/Solana/Solana.ts","../../src/chain-adapters/Aptos/index.ts","../../src/chain-adapters/Aptos/Aptos.ts","../../src/chain-adapters/SUI/index.ts","../../src/chain-adapters/SUI/SUI.ts","../../src/chain-adapters/XRP/index.ts","../../src/chain-adapters/XRP/XRP.ts","../../src/chain-adapters/NEAR/index.ts","../../src/chain-adapters/NEAR/NEAR.ts","../../src/chain-adapters/NEAR/utils.ts","../../src/contracts/index.ts","../../src/contracts/transaction.ts","../../src/contracts/constants.ts","../../src/contracts/ChainSignatureContract.ts"],"names":["constants_exports","__export","CHAINS","CONTRACT_ADDRESSES","ENVS","KDF_CHAIN_IDS","ROOT_PUBLIC_KEYS","utils_exports","cryptography_exports","compressPubKey","deriveChildPublicKey","najToUncompressedPubKeySEC1","toRSV","uint8ArrayToHex","signature","uncompressedPubKeySEC1","slicedPubKey","x","y","najPublicKey","decodedKey","base58","rootUncompressedPubKeySEC1","predecessorId","path","chainId","ec","elliptic","derivationPath","scalarHex","keccak256","sha","oldPublicKeyPoint","scalarTimesG","newPublicKeyPoint","newX","newY","uint8Array","byte","chain_adapters_exports","ChainAdapter","Aptos_exports","Bitcoin_exports","Cosmos_exports","EVM_exports","NEAR_exports","Solana_exports","SUI_exports","XRP_exports","EVM","fetchEVMFeeProperties","client","transaction","gasPromise","feeDataPromise","gas","feeData","maxFeePerGas","maxPriorityFeePerGas","publicClient","contract","fees","nonce","from","rest","gasPrice","r","s","yParity","concatHex","numberToHex","predecessor","uncompressedPubKey","publicKeyNoPrefix","hash","getAddress","address","serializeTransaction","serialized","parseTransaction","transactionRequest","serializedTx","txHash","toBytes","message","hashMessage","typedDataRequest","hashTypedData","userOp","entryPointAddress","chainIdArgs","entryPoint","encoded","encodeAbiParameters","hexToBigInt","concat","pad","isAddress","userOpHash","params","hashAuthorization","rsvSignatures","rsvSignature","txSerialized","error","BTCRpcAdapter","BTCRpcAdapters","Bitcoin","Mempool","parseBTCNetwork","network","_","_Bitcoin","btcRpcAdapter","satoshis","btc","transactionId","data","tx","vout","scriptPubKey","rawSignature","inputs","outputs","psbt","input","prevOut","out","derivedKey","publicKeyBuffer","payment","transactionJSON","psbtHex","hashesToSign","mockKeyPair","index","publicKey","keyPair","mpcSignature","providerUrl","confirmationTarget","targets","utxos","feeRate","ret","coinselect","transactionHex","response","txid","Cosmos","fetchChainInfo","chainInfo","chains","chain","prefix","expectedChainId","denom","rpcUrl","restUrl","asset","assets","decimals","unit","endpoints","Registry","fromHex","amount","b","pubKeySha256","sha256","ripemd160Hash","ripemd160","bech32","TxRaw","toBase64","fromBase64","publicKeyBytes","gasLimit","fee","calculateFee","GasPrice","accountOnChain","StargateClient","accountNumber","sequence","txBodyEncodeObject","txBodyBytes","pubkey","encodePubkey","encodeSecp256k1Pubkey","authInfoBytes","makeAuthInfoBytes","SignMode","signDoc","makeSignDoc","signBytes","makeSignBytes","payload","sig","txBytes","broadcastResponse","Solana","toBigInt","value","args","PublicKey","balance","pubKey","base58Key","buffer","Transaction","request","SystemProgram","blockhash","messageBytes","senderAddress","signatureBuffer","Aptos","bytes","bs58","Ed25519PublicKey","isPrefixWith0x","deserializer","Deserializer","MultiAgentTransaction","SimpleTransaction","generateSigningMessageForTransaction","isPublicKeyPrefixWith0x","AccountAuthenticatorEd25519","Ed25519Signature","senderAuthenticator","signedTx","generateSignedTransaction","serializedSignedTransaction","SignedTransaction","signedTransaction","postAptosFullNode","MimeType","e","KeylessPublicKey","FederatedKeylessPublicKey","AbstractKeylessAccount","SUI","SuiHTTPTransport","pubKeyInSui","intentMessage","messageWithIntent","blake2b","rawPublicKeyBuffer","toSerializedSignature","XRP","Client","disconnectError","compressedPubKey","publicKeyHex","sha256Hash","createHash","encodeAccountID","signingPubKey","prepared","unsignedTx","encodedTx","encodeTx","signingPrefix","encodedBytes","signingData","signingHash","derSignature","v","rBuf","sBuf","rVal","sVal","totalLength","offset","txBlob","NEAR","sha256Bytes","cryptoAny","digest","JsonRpcProvider","msg","res","pk","NearPublicKey","unsigned","nearEncodeTransaction","NearTransaction","to","accessKey","block","recentBlockHash","baseDecode","txPublicKey","nextNonce","actions","NearAction","NearTransfer","nearCreateTransaction","signatureBytes","txObj","NearSignedTransaction","NearSignature","signedTxBytes","ensureDerivedAccountExists","provider","controllerAccountId","controllerKeyPair","derivedAccountId","mpcPublicKey","initialDepositYocto","acc","controllerPubKey","nearMpcPubKey","NearCreateAccount","NearAddKey","NearAccessKey","NearAccessKeyPermission","NearFullAccessPermission","contracts_exports","ChainSignatureContract","utils","transaction_exports","responseToMpcSignature","NEAR_MAX_GAS","contractId","networkId","fallbackRpcUrls","rpcProviderUrls","FailoverRpcProvider","url","payloads","keyType","signerAccount","transactions","actionCreators","getTransactionLastResult","najPubKey"],"mappings":"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","file":"index.node.js","sourcesContent":["import { type NajPublicKey } from '@types'\n\nexport const ENVS = {\n  TESTNET_DEV: 'TESTNET_DEV',\n  TESTNET: 'TESTNET',\n  MAINNET: 'MAINNET',\n} as const\n\nexport const CHAINS = {\n  ETHEREUM: 'ETHEREUM',\n  NEAR: 'NEAR',\n} as const\n\n/**\n * Root public keys for the Sig Network Smart Contracts across different environments.\n *\n * These keys should never change.\n */\nexport const ROOT_PUBLIC_KEYS: Record<keyof typeof ENVS, NajPublicKey> = {\n  [ENVS.TESTNET_DEV]:\n    'secp256k1:54hU5wcCmVUPFWLDALXMh1fFToZsVXrx9BbTbHzSfQq1Kd1rJZi52iPa4QQxo6s5TgjWqgpY8HamYuUDzG6fAaUq',\n  [ENVS.TESTNET]:\n    'secp256k1:3Ww8iFjqTHufye5aRGUvrQqETegR4gVUcW8FX5xzscaN9ENhpkffojsxJwi6N1RbbHMTxYa9UyKeqK3fsMuwxjR5',\n  [ENVS.MAINNET]:\n    'secp256k1:4tY4qMzusmgX5wYdG35663Y3Qar3CTbpApotwk9ZKLoF79XA4DjG8XoByaKdNHKQX9Lz5hd7iJqsWdTKyA7dKa6Z',\n}\n\n/**\n * Chain IDs used in the key derivation function (KDF) for deriving child public keys to\n * distinguish between different chains.\n *\n * @see {@link utils.cryptography.deriveChildPublicKey} for usage details\n */\nexport const KDF_CHAIN_IDS = {\n  [CHAINS.ETHEREUM]: '0x1',\n  [CHAINS.NEAR]: '0x18d',\n} as const\n\n/**\n * Contract addresses for different chains and environments.\n *\n * - Testnet Dev: Used for internal development, very unstable\n * - Testnet: Used for external development, stable\n * - Mainnet: Production contract address\n *\n * @see ChainSignatureContract documentation for implementation details\n */\nexport const CONTRACT_ADDRESSES: Record<\n  keyof typeof CHAINS,\n  Record<keyof typeof ENVS, string>\n> = {\n  [CHAINS.NEAR]: {\n    [ENVS.TESTNET_DEV]: 'dev.sig-net.testnet',\n    [ENVS.TESTNET]: 'v1.sig-net.testnet',\n    [ENVS.MAINNET]: 'v1.sig-net.near',\n  },\n  [CHAINS.ETHEREUM]: {\n    [ENVS.TESTNET_DEV]: '0x69C6b28Fdc74618817fa380De29a653060e14009',\n    [ENVS.TESTNET]: '0x83458E8Bf8206131Fe5c05127007FA164c0948A2',\n    [ENVS.MAINNET]: '0xf8bdC0612361a1E49a8E01423d4C0cFc5dF4791A',\n  },\n}\n","export * as cryptography from './cryptography'\n","import { base58 } from '@scure/base'\nimport elliptic from 'elliptic'\nimport sha from 'js-sha3'\nimport { keccak256 } from 'viem'\n\nimport { KDF_CHAIN_IDS } from '@constants'\nimport {\n  type NajPublicKey,\n  type MPCSignature,\n  type RSVSignature,\n  type UncompressedPubKeySEC1,\n} from '@types'\n\nexport const toRSV = (signature: MPCSignature): RSVSignature => {\n  // Handle NearNearMpcSignature\n  if (\n    'big_r' in signature &&\n    typeof signature.big_r === 'object' &&\n    'affine_point' in signature.big_r &&\n    's' in signature &&\n    typeof signature.s === 'object' &&\n    'scalar' in signature.s\n  ) {\n    return {\n      r: signature.big_r.affine_point.substring(2),\n      s: signature.s.scalar,\n      v: signature.recovery_id + 27,\n    }\n  }\n  // Handle ChainSigNearMpcSignature\n  else if (\n    'big_r' in signature &&\n    typeof signature.big_r === 'string' &&\n    's' in signature &&\n    typeof signature.s === 'string'\n  ) {\n    return {\n      r: signature.big_r.substring(2),\n      s: signature.s,\n      v: signature.recovery_id + 27,\n    }\n  }\n  // Handle ChainSigEvmMpcSignature\n  else if (\n    'bigR' in signature &&\n    'x' in signature.bigR &&\n    's' in signature &&\n    typeof signature.s === 'bigint'\n  ) {\n    return {\n      r: signature.bigR.x.toString(16).padStart(64, '0'),\n      s: signature.s.toString(16).padStart(64, '0'),\n      v: signature.recoveryId + 27,\n    }\n  }\n\n  throw new Error('Invalid signature format')\n}\n\n/**\n * Compresses an uncompressed public key to its compressed format following SEC1 standards.\n * In SEC1, a compressed public key consists of a prefix (02 or 03) followed by the x-coordinate.\n * The prefix indicates whether the y-coordinate is even (02) or odd (03).\n *\n * @param uncompressedPubKeySEC1 - The uncompressed public key in hex format, with or without '04' prefix\n * @returns The compressed public key in hex format\n * @throws Error if the uncompressed public key length is invalid\n */\nexport const compressPubKey = (\n  uncompressedPubKeySEC1: UncompressedPubKeySEC1\n): string => {\n  const slicedPubKey = uncompressedPubKeySEC1.slice(2)\n\n  if (slicedPubKey.length !== 128) {\n    throw new Error('Invalid uncompressed public key length')\n  }\n\n  const x = slicedPubKey.slice(0, 64)\n  const y = slicedPubKey.slice(64)\n\n  const isEven = parseInt(y.slice(-1), 16) % 2 === 0\n  const prefix = isEven ? '02' : '03'\n\n  return prefix + x\n}\n\n/**\n * Converts a NAJ public key to an uncompressed SEC1 public key.\n *\n * @param najPublicKey - The NAJ public key to convert (e.g. secp256k1:3Ww8iFjqTHufye5aRGUvrQqETegR4gVUcW8FX5xzscaN9ENhpkffojsxJwi6N1RbbHMTxYa9UyKeqK3fsMuwxjR5)\n * @returns The uncompressed SEC1 public key (e.g. 04 || x || y)\n */\nexport const najToUncompressedPubKeySEC1 = (\n  najPublicKey: NajPublicKey\n): UncompressedPubKeySEC1 => {\n  const decodedKey = base58.decode(najPublicKey.split(':')[1])\n  return `04${Buffer.from(decodedKey).toString('hex')}`\n}\n\n/**\n * Derives a child public key from a parent public key using the sig.network v1.0.0 epsilon derivation scheme.\n * The parent public keys are defined in @constants.ts\n *\n * @param rootUncompressedPubKeySEC1 - The parent public key in uncompressed SEC1 format (e.g. 04 || x || y)\n * @param predecessorId - The predecessor ID is the address of the account calling the signer contract (e.g EOA or Contract Address)\n * @param path - Optional derivation path suffix (defaults to empty string)\n * @param chainId - The chain ID for key derivation\n * @returns The derived child public key in uncompressed SEC1 format (04 || x || y)\n */\nexport function deriveChildPublicKey(\n  rootUncompressedPubKeySEC1: UncompressedPubKeySEC1,\n  predecessorId: string,\n  path: string = '',\n  chainId: string\n): UncompressedPubKeySEC1 {\n  // eslint-disable-next-line new-cap\n  const ec = new elliptic.ec('secp256k1')\n\n  const EPSILON_DERIVATION_PREFIX = 'sig.network v1.0.0 epsilon derivation'\n  const derivationPath = `${EPSILON_DERIVATION_PREFIX},${chainId},${predecessorId},${path}`\n\n  let scalarHex = ''\n\n  if (chainId === KDF_CHAIN_IDS.ETHEREUM) {\n    scalarHex = keccak256(Buffer.from(derivationPath)).slice(2)\n  } else if (chainId === KDF_CHAIN_IDS.NEAR) {\n    scalarHex = sha.sha3_256(derivationPath)\n  } else {\n    throw new Error('Invalid chain ID')\n  }\n\n  const x = rootUncompressedPubKeySEC1.substring(2, 66)\n  const y = rootUncompressedPubKeySEC1.substring(66)\n\n  const oldPublicKeyPoint = ec.curve.point(x, y)\n  const scalarTimesG = ec.g.mul(scalarHex)\n  const newPublicKeyPoint = oldPublicKeyPoint.add(scalarTimesG)\n\n  const newX = newPublicKeyPoint.getX().toString('hex').padStart(64, '0')\n  const newY = newPublicKeyPoint.getY().toString('hex').padStart(64, '0')\n\n  return `04${newX}${newY}`\n}\n\n/**\n * Converts a Uint8Array to a hexadecimal string.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The hexadecimal string representation of the Uint8Array.\n */\nexport const uint8ArrayToHex = (\n  uint8Array: number[] | Uint8Array<ArrayBufferLike>\n): string => {\n  return Array.from(uint8Array)\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('')\n}\n","export { ChainAdapter } from './ChainAdapter'\n\nexport * as evm from './EVM'\nexport * as btc from './Bitcoin'\nexport * as cosmos from './Cosmos'\nexport * as solana from './Solana'\nexport * as aptos from './Aptos'\nexport * as sui from './SUI'\nexport * as xrp from './XRP'\nexport * as near from './NEAR'\n","import { type Transaction } from '@solana/web3.js'\n\nimport type { HashToSign, RSVSignature, Signature } from '@types'\n\nexport abstract class ChainAdapter<TransactionRequest, UnsignedTransaction> {\n  /**\n   * Gets the native token balance and decimals for a given address\n   *\n   * @param address - The address to check\n   * @returns Promise resolving to an object containing:\n   *          - balance: The balance as a bigint, in the chain's base units\n   *          - decimals: The number of decimals used to format the balance\n   */\n  abstract getBalance(address: string): Promise<{\n    balance: bigint\n    decimals: number\n  }>\n\n  /**\n   * Uses Sig Network Key Derivation Function to derive the address and public key. from a signer ID and string path.\n   *\n   * @param predecessor - The id/address of the account requesting signature\n   * @param path - The string path used to derive the key\n   * @returns Promise resolving to the derived address and public key\n   */\n  abstract deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{\n    address: string\n    publicKey: string\n  }>\n\n  /**\n   * Serializes an unsigned transaction to a string format.\n   * This is useful for storing or transmitting the transaction.\n   *\n   * @param transaction - The unsigned transaction to serialize\n   * @returns The serialized transaction string\n   */\n  abstract serializeTransaction(transaction: UnsignedTransaction): string\n\n  /**\n   * Deserializes a transaction string back into an unsigned transaction object.\n   * This reverses the serialization done by serializeTransaction().\n   *\n   * @param serialized - The serialized transaction string\n   * @returns The deserialized unsigned transaction\n   */\n  abstract deserializeTransaction(serialized: string): UnsignedTransaction\n\n  /**\n   * Prepares a transaction for Sig Network MPC signing by creating the necessary payloads.\n   * This method handles chain-specific transaction preparation including:\n   * - Fee calculation\n   * - Nonce/sequence management\n   * - UTXO selection (for UTXO-based chains)\n   * - Transaction encoding\n   *\n   * @param transactionRequest - The transaction request containing parameters like recipient, amount, etc.\n   * @returns Promise resolving to an object containing:\n   *          - transaction: The unsigned transaction\n   *          - hashesToSign: Array of payloads to be signed by MPC. The order of these payloads must match\n   *                         the order of signatures provided to finalizeTransactionSigning()\n   */\n  abstract prepareTransactionForSigning(\n    transactionRequest: TransactionRequest\n  ): Promise<{\n    transaction: UnsignedTransaction\n    hashesToSign: HashToSign[]\n  }>\n\n  /**\n   * Adds Sig Network MPC-generated signatures to an unsigned transaction.\n   *\n   * @param params - Parameters for adding signatures\n   * @param params.transaction - The unsigned transaction to add signatures to\n   * @param params.rsvSignatures - Array of RSV signatures generated through MPC. Must be in the same order\n   *                              as the payloads returned by prepareTransactionForSigning()\n   * @returns The serialized signed transaction ready for broadcast\n   */\n  abstract finalizeTransactionSigning(params: {\n    transaction: UnsignedTransaction | Transaction\n    rsvSignatures: RSVSignature[] | Signature\n  }): string\n\n  /**\n   * Broadcasts a signed transaction to the network.\n   *\n   * @param txSerialized - The serialized signed transaction\n   * @returns Promise resolving to an object containing the transaction hash/ID\n   */\n  abstract broadcastTx(txSerialized: string): Promise<{ hash: string }>\n}\n","// EVM\nexport { EVM } from './EVM'\n\nexport { fetchEVMFeeProperties, type EVMFeeProperties } from './utils'\n\nexport type {\n  EVMTransactionRequest,\n  EVMUnsignedTransaction,\n  EVMMessage,\n  EVMTypedData,\n  EVMTransactionRequestLegacy,\n  EVMUnsignedLegacyTransaction,\n  EVMAuthorizationRequest,\n  UserOperationV6,\n  UserOperationV7,\n} from './types'\n","import {\n  parseTransaction,\n  type PublicClient,\n  hashMessage,\n  hashTypedData,\n  keccak256,\n  toBytes,\n  type Hex,\n  serializeTransaction,\n  type Signature,\n  numberToHex,\n  getAddress,\n  type Address,\n  type Hash,\n  concatHex,\n  encodeAbiParameters,\n  hexToBigInt,\n  concat,\n  pad,\n  isAddress,\n  type SignedAuthorization,\n} from 'viem'\nimport { hashAuthorization } from 'viem/experimental'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport type {\n  EVMTransactionRequest,\n  EVMUnsignedTransaction,\n  EVMMessage,\n  EVMTypedData,\n  UserOperationV6,\n  UserOperationV7,\n  EVMAuthorizationRequest,\n  EVMTransactionRequestLegacy,\n  EVMUnsignedLegacyTransaction,\n} from '@chain-adapters/EVM/types'\nimport { fetchEVMFeeProperties } from '@chain-adapters/EVM/utils'\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, RSVSignature } from '@types'\n\n/**\n * Implementation of the ChainAdapter interface for EVM-compatible networks.\n * Handles interactions with Ethereum Virtual Machine based blockchains like Ethereum, BSC, Polygon, etc.\n */\nexport class EVM extends ChainAdapter<EVMTransactionRequest, EVMUnsignedTransaction> {\n  private readonly client: PublicClient\n  private readonly contract: ChainSignatureContract\n\n  /**\n   * Creates a new EVM chain instance\n   * @param params - Configuration parameters\n   * @param params.publicClient - A Viem PublicClient instance for reading from the blockchain\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   */\n  constructor({\n    publicClient,\n    contract,\n  }: {\n    publicClient: PublicClient\n    contract: ChainSignatureContract\n  }) {\n    super()\n\n    this.contract = contract\n    this.client = publicClient\n  }\n\n  private async attachGasAndNonce(\n    transaction: EVMTransactionRequest\n  ): Promise<EVMUnsignedTransaction> {\n    const fees = await fetchEVMFeeProperties(this.client, transaction)\n    const nonce =\n      transaction.nonce ??\n      (await this.client.getTransactionCount({\n        address: transaction.from,\n      }))\n\n    const { from, ...rest } = transaction\n\n    return {\n      ...fees,\n      nonce,\n      chainId: Number(await this.client.getChainId()),\n      type: 'eip1559',\n      ...rest,\n    }\n  }\n\n  private async attachGasAndNonceLegacy(\n    transaction: EVMTransactionRequestLegacy\n  ): Promise<EVMUnsignedLegacyTransaction> {\n    const gasPrice = transaction.gasPrice ?? (await this.client.getGasPrice())\n    const nonce =\n      transaction.nonce ??\n      (await this.client.getTransactionCount({\n        address: transaction.from,\n      }))\n\n    const { from, ...rest } = transaction\n\n    return {\n      ...rest,\n      gasPrice: BigInt(gasPrice),\n      nonce: Number(nonce),\n      value: rest.value !== undefined ? BigInt(rest.value) : undefined,\n      gas: rest.gas !== undefined ? BigInt(rest.gas) : BigInt(21000),\n      chainId: await this.client.getChainId(),\n      type: 'legacy',\n    }\n  }\n\n  private transformRSVSignature(signature: RSVSignature): Signature {\n    return {\n      r: `0x${signature.r}`,\n      s: `0x${signature.s}`,\n      yParity: signature.v - 27,\n    }\n  }\n\n  private assembleSignature(signature: RSVSignature): Hex {\n    const { r, s, yParity } = this.transformRSVSignature(signature)\n\n    if (yParity === undefined) {\n      throw new Error('Missing yParity')\n    }\n\n    return concatHex([r, s, numberToHex(yParity + 27, { size: 1 })])\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{\n    address: string\n    publicKey: string\n  }> {\n    const uncompressedPubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n    })\n\n    if (!uncompressedPubKey) {\n      throw new Error('Failed to get derived public key')\n    }\n\n    const publicKeyNoPrefix = uncompressedPubKey.startsWith('04')\n      ? uncompressedPubKey.slice(2)\n      : uncompressedPubKey\n\n    const hash = keccak256(Buffer.from(publicKeyNoPrefix, 'hex'))\n    const address = getAddress(`0x${hash.slice(-40)}`)\n\n    return {\n      address,\n      publicKey: uncompressedPubKey,\n    }\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const balance = await this.client.getBalance({\n      address: address as Address,\n    })\n    return {\n      balance,\n      decimals: 18,\n    }\n  }\n\n  serializeTransaction(transaction: EVMUnsignedTransaction): `0x${string}` {\n    return serializeTransaction(transaction)\n  }\n\n  deserializeTransaction(serialized: `0x${string}`): EVMUnsignedTransaction {\n    return parseTransaction(serialized) as EVMUnsignedTransaction\n  }\n\n  async prepareTransactionForSigning(\n    transactionRequest: EVMTransactionRequest\n  ): Promise<{\n    transaction: EVMUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const transaction = await this.attachGasAndNonce(transactionRequest)\n\n    const serializedTx = serializeTransaction(transaction)\n    const txHash = toBytes(keccak256(serializedTx))\n\n    return {\n      transaction,\n      hashesToSign: [Array.from(txHash)],\n    }\n  }\n\n  async prepareTransactionForSigningLegacy(\n    transactionRequest: EVMTransactionRequestLegacy\n  ): Promise<{\n    transaction: EVMUnsignedLegacyTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const transaction = await this.attachGasAndNonceLegacy(transactionRequest)\n    const serializedTx = serializeTransaction(transaction)\n    const txHash = toBytes(keccak256(serializedTx))\n    return {\n      transaction,\n      hashesToSign: [Array.from(txHash)],\n    }\n  }\n\n  async prepareMessageForSigning(message: EVMMessage): Promise<{\n    hashToSign: HashToSign\n  }> {\n    return {\n      hashToSign: Array.from(toBytes(hashMessage(message))),\n    }\n  }\n\n  async prepareTypedDataForSigning(typedDataRequest: EVMTypedData): Promise<{\n    hashToSign: HashToSign\n  }> {\n    return {\n      hashToSign: Array.from(toBytes(hashTypedData(typedDataRequest))),\n    }\n  }\n\n  /**\n   * This implementation is a common step for Biconomy and Alchemy.\n   * Key differences between implementations:\n   * - Signature format: Biconomy omits 0x00 prefix when concatenating, Alchemy includes it\n   * - Version support: Biconomy only supports v6, Alchemy supports both v6 and v7\n   * - Validation: Biconomy uses modules for signature validation, Alchemy uses built-in validation\n   */\n  async prepareUserOpForSigning(\n    userOp: UserOperationV7 | UserOperationV6,\n    entryPointAddress?: Address,\n    chainIdArgs?: number\n  ): Promise<{\n    userOp: UserOperationV7 | UserOperationV6\n    hashToSign: HashToSign\n  }> {\n    const chainId = chainIdArgs ?? (await this.client.getChainId())\n    const entryPoint =\n      entryPointAddress || '0x0000000071727De22E5E9d8BAf0edAc6f37da032'\n\n    const encoded = encodeAbiParameters(\n      [{ type: 'bytes32' }, { type: 'address' }, { type: 'uint256' }],\n      [\n        keccak256(\n          encodeAbiParameters(\n            [\n              { type: 'address' },\n              { type: 'uint256' },\n              { type: 'bytes32' },\n              { type: 'bytes32' },\n              { type: 'bytes32' },\n              { type: 'uint256' },\n              { type: 'bytes32' },\n              { type: 'bytes32' },\n            ],\n            [\n              userOp.sender,\n              hexToBigInt(userOp.nonce),\n              keccak256(\n                'factory' in userOp &&\n                  'factoryData' in userOp &&\n                  userOp.factory &&\n                  userOp.factoryData\n                  ? concat([userOp.factory, userOp.factoryData])\n                  : 'initCode' in userOp\n                    ? userOp.initCode\n                    : '0x'\n              ),\n              keccak256(userOp.callData),\n              concat([\n                pad(userOp.verificationGasLimit, { size: 16 }),\n                pad(userOp.callGasLimit, { size: 16 }),\n              ]),\n              hexToBigInt(userOp.preVerificationGas),\n              concat([\n                pad(userOp.maxPriorityFeePerGas, { size: 16 }),\n                pad(userOp.maxFeePerGas, { size: 16 }),\n              ]),\n              keccak256(\n                'paymaster' in userOp &&\n                  userOp.paymaster &&\n                  isAddress(userOp.paymaster)\n                  ? concat([\n                      userOp.paymaster,\n                      pad(userOp.paymasterVerificationGasLimit, { size: 16 }),\n                      pad(userOp.paymasterPostOpGasLimit, { size: 16 }),\n                      userOp.paymasterData,\n                    ])\n                  : 'paymasterAndData' in userOp\n                    ? userOp.paymasterAndData\n                    : '0x'\n              ),\n            ]\n          )\n        ),\n        entryPoint,\n        BigInt(chainId),\n      ]\n    )\n\n    const userOpHash = keccak256(encoded)\n\n    return {\n      userOp,\n      hashToSign: Array.from(toBytes(hashMessage({ raw: userOpHash }))),\n    }\n  }\n\n  prepareAuthorizationForSigning(params: EVMAuthorizationRequest): {\n    hashToSign: HashToSign\n  } {\n    const address = params.contractAddress ?? params.address\n    return {\n      hashToSign: Array.from(\n        toBytes(\n          hashAuthorization({\n            address,\n            chainId: params.chainId,\n            nonce: params.nonce,\n          })\n        )\n      ),\n    }\n  }\n\n  finalizeTransactionSigning({\n    transaction,\n    rsvSignatures,\n  }: {\n    transaction: EVMUnsignedTransaction\n    rsvSignatures: RSVSignature[]\n  }): `0x02${string}` {\n    const signature = this.transformRSVSignature(rsvSignatures[0])\n\n    return serializeTransaction(transaction, signature)\n  }\n\n  public finalizeTransactionSigningLegacy({\n    transaction,\n    rsvSignatures,\n  }: {\n    transaction: EVMUnsignedLegacyTransaction\n    rsvSignatures: RSVSignature[]\n  }): `0x${string}` {\n    const signature = {\n      v: BigInt(rsvSignatures[0].v),\n      r: `0x${rsvSignatures[0].r.padStart(64, '0')}` as `0x${string}`,\n      s: `0x${rsvSignatures[0].s.padStart(64, '0')}` as `0x${string}`,\n      yParity: rsvSignatures[0].v - 27,\n    }\n\n    return serializeTransaction(transaction, signature)\n  }\n\n  finalizeMessageSigning({\n    rsvSignature,\n  }: {\n    rsvSignature: RSVSignature\n  }): Hex {\n    return this.assembleSignature(rsvSignature)\n  }\n\n  finalizeTypedDataSigning({\n    rsvSignature,\n  }: {\n    rsvSignature: RSVSignature\n  }): Hex {\n    return this.assembleSignature(rsvSignature)\n  }\n\n  finalizeUserOpSigning({\n    userOp,\n    rsvSignature,\n  }: {\n    userOp: UserOperationV7 | UserOperationV6\n    rsvSignature: RSVSignature\n  }): UserOperationV7 | UserOperationV6 {\n    const { r, s, yParity } = this.transformRSVSignature(rsvSignature)\n    if (yParity === undefined) {\n      throw new Error('Missing yParity')\n    }\n\n    return {\n      ...userOp,\n      signature: concatHex([\n        '0x00', // Alchemy specific implementation. Biconomy doesn't include the 0x00 prefix.\n        r,\n        s,\n        numberToHex(Number(yParity + 27), { size: 1 }),\n      ]),\n    }\n  }\n\n  finalizeAuthorizationSigning(params: {\n    authorization: EVMAuthorizationRequest\n    rsvSignature: RSVSignature\n  }): SignedAuthorization {\n    return {\n      address:\n        params.authorization.contractAddress ?? params.authorization.address,\n      chainId: params.authorization.chainId,\n      nonce: params.authorization.nonce,\n      ...this.transformRSVSignature(params.rsvSignature),\n    }\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: Hash }> {\n    try {\n      const hash = await this.client.sendRawTransaction({\n        serializedTransaction: txSerialized as `0x${string}`,\n      })\n      return { hash }\n    } catch (error) {\n      console.error('Transaction broadcast failed:', error)\n      throw new Error('Failed to broadcast transaction.')\n    }\n  }\n}\n","import { type PublicClient, type TransactionRequest } from 'viem'\n\nexport interface EVMFeeProperties {\n  gas: bigint\n  maxFeePerGas: bigint\n  maxPriorityFeePerGas: bigint\n}\n\nexport async function fetchEVMFeeProperties(\n  client: PublicClient,\n  transaction: TransactionRequest\n): Promise<EVMFeeProperties> {\n  const gasPromise = transaction.gas\n    ? Promise.resolve(transaction.gas)\n    : client.estimateGas({ account: transaction.from, ...transaction })\n  const feeDataPromise =\n    transaction.maxFeePerGas && transaction.maxPriorityFeePerGas\n      ? Promise.resolve({\n          maxFeePerGas: transaction.maxFeePerGas,\n          maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,\n        })\n      : client.estimateFeesPerGas()\n\n  const [gas, feeData] = await Promise.all([gasPromise, feeDataPromise])\n\n  const maxFeePerGas = feeData.maxFeePerGas ?? BigInt(10_000_000_000) // 10 gwei\n  const maxPriorityFeePerGas =\n    feeData.maxPriorityFeePerGas ?? BigInt(10_000_000_000) // 10 gwei\n\n  return {\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  }\n}\n","// Bitcoin\nexport { Bitcoin } from './Bitcoin'\n\nexport { BTCRpcAdapters, BTCRpcAdapter } from './BTCRpcAdapter'\n\nexport type {\n  BTCTransactionRequest,\n  BTCUnsignedTransaction,\n  BTCTransaction,\n  BTCOutput,\n  BTCInput,\n  BTCNetworkIds,\n} from './types'\n\nexport { Mempool } from './BTCRpcAdapter/Mempool'\n","import * as bitcoin from 'bitcoinjs-lib'\n\nexport function parseBTCNetwork(network: string): bitcoin.networks.Network {\n  switch (network.toLowerCase()) {\n    case 'mainnet':\n      return bitcoin.networks.bitcoin\n    case 'testnet':\n      return bitcoin.networks.testnet\n    case 'regtest':\n      return bitcoin.networks.regtest\n    default:\n      throw new Error(`Unknown Bitcoin network: ${network}`)\n  }\n}\n","import * as bitcoin from 'bitcoinjs-lib'\n\nimport { type BTCRpcAdapter } from '@chain-adapters/Bitcoin/BTCRpcAdapter'\nimport type {\n  BTCInput,\n  BTCNetworkIds,\n  BTCOutput,\n  BTCTransactionRequest,\n  BTCUnsignedTransaction,\n} from '@chain-adapters/Bitcoin/types'\nimport { parseBTCNetwork } from '@chain-adapters/Bitcoin/utils'\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, RSVSignature, UncompressedPubKeySEC1 } from '@types'\nimport { cryptography } from '@utils'\n\n/**\n * Implementation of the ChainAdapter interface for Bitcoin network.\n * Handles interactions with both Bitcoin mainnet and testnet, supporting P2WPKH transactions.\n */\nexport class Bitcoin extends ChainAdapter<\n  BTCTransactionRequest,\n  BTCUnsignedTransaction\n> {\n  private static readonly SATOSHIS_PER_BTC = 100_000_000\n\n  private readonly network: BTCNetworkIds\n  private readonly btcRpcAdapter: BTCRpcAdapter\n  private readonly contract: ChainSignatureContract\n\n  /**\n   * Creates a new Bitcoin chain instance\n   * @param params - Configuration parameters\n   * @param params.network - Network identifier (mainnet/testnet)\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   * @param params.btcRpcAdapter - Bitcoin RPC adapter for network interactions\n   */\n  constructor({\n    network,\n    contract,\n    btcRpcAdapter,\n  }: {\n    network: BTCNetworkIds\n    contract: ChainSignatureContract\n    btcRpcAdapter: BTCRpcAdapter\n  }) {\n    super()\n\n    this.network = network\n    this.btcRpcAdapter = btcRpcAdapter\n    this.contract = contract\n  }\n\n  /**\n   * Converts satoshis to BTC\n   * @param satoshis - Amount in satoshis\n   * @returns Amount in BTC\n   */\n  static toBTC(satoshis: number): number {\n    return satoshis / Bitcoin.SATOSHIS_PER_BTC\n  }\n\n  /**\n   * Converts BTC to satoshis\n   * @param btc - Amount in BTC\n   * @returns Amount in satoshis (rounded)\n   */\n  static toSatoshi(btc: number): number {\n    return Math.round(btc * Bitcoin.SATOSHIS_PER_BTC)\n  }\n\n  private async fetchTransaction(\n    transactionId: string\n  ): Promise<bitcoin.Transaction> {\n    const data = await this.btcRpcAdapter.getTransaction(transactionId)\n    const tx = new bitcoin.Transaction()\n\n    data.vout.forEach((vout) => {\n      const scriptPubKey = Buffer.from(vout.scriptpubkey, 'hex')\n      tx.addOutput(scriptPubKey, Number(vout.value))\n    })\n\n    return tx\n  }\n\n  private static transformRSVSignature(signature: RSVSignature): Buffer {\n    const r = signature.r.padStart(64, '0')\n    const s = signature.s.padStart(64, '0')\n\n    const rawSignature = Buffer.from(r + s, 'hex')\n\n    if (rawSignature.length !== 64) {\n      throw new Error('Invalid signature length.')\n    }\n\n    return rawSignature\n  }\n\n  /**\n   * Creates a Partially Signed Bitcoin Transaction (PSBT)\n   * @param params - Parameters for creating the PSBT\n   * @param params.transactionRequest - Transaction request containing inputs and outputs\n   * @returns Created PSBT instance\n   */\n  async createPSBT({\n    transactionRequest,\n  }: {\n    transactionRequest: BTCTransactionRequest\n  }): Promise<bitcoin.Psbt> {\n    const { inputs, outputs } =\n      transactionRequest.inputs && transactionRequest.outputs\n        ? transactionRequest\n        : await this.btcRpcAdapter.selectUTXOs(transactionRequest.from, [\n            {\n              address: transactionRequest.to,\n              value: parseFloat(transactionRequest.value),\n            },\n          ])\n\n    const psbt = new bitcoin.Psbt({ network: parseBTCNetwork(this.network) })\n\n    await Promise.all(\n      inputs.map(async (input: BTCInput) => {\n        if (!input.scriptPubKey) {\n          const transaction = await this.fetchTransaction(input.txid)\n          const prevOut = transaction.outs[input.vout]\n          input.scriptPubKey = prevOut.script\n        }\n\n        // Prepare the input as P2WPKH\n        psbt.addInput({\n          hash: input.txid,\n          index: input.vout,\n          witnessUtxo: {\n            script: input.scriptPubKey,\n            value: input.value,\n          },\n        })\n      })\n    )\n\n    outputs.forEach((out: BTCOutput) => {\n      if ('address' in out) {\n        psbt.addOutput({\n          address: out.address,\n          value: out.value,\n        })\n      } else if ('script' in out) {\n        psbt.addOutput({\n          script: out.script,\n          value: out.value,\n        })\n      } else if (transactionRequest.from !== undefined) {\n        // Include change address from coinselect\n        psbt.addOutput({\n          value: Number(out.value),\n          address: transactionRequest.from,\n        })\n      }\n    })\n\n    return psbt\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const balance = BigInt(await this.btcRpcAdapter.getBalance(address))\n    return {\n      balance,\n      decimals: 8,\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const uncompressedPubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n    })\n\n    if (!uncompressedPubKey) {\n      throw new Error('Failed to get derived public key')\n    }\n\n    const derivedKey = cryptography.compressPubKey(\n      uncompressedPubKey as UncompressedPubKeySEC1\n    )\n    const publicKeyBuffer = Buffer.from(derivedKey, 'hex')\n    const network = parseBTCNetwork(this.network)\n\n    const payment = bitcoin.payments.p2wpkh({\n      pubkey: publicKeyBuffer,\n      network,\n    })\n\n    const { address } = payment\n\n    if (!address) {\n      throw new Error('Failed to generate Bitcoin address')\n    }\n\n    return { address, publicKey: derivedKey }\n  }\n\n  serializeTransaction(transaction: BTCUnsignedTransaction): string {\n    return JSON.stringify({\n      psbt: transaction.psbt.toHex(),\n      publicKey: transaction.publicKey,\n    })\n  }\n\n  deserializeTransaction(serialized: string): BTCUnsignedTransaction {\n    const transactionJSON = JSON.parse(serialized)\n    return {\n      psbt: bitcoin.Psbt.fromHex(transactionJSON.psbt as string),\n      publicKey: transactionJSON.publicKey,\n    }\n  }\n\n  async prepareTransactionForSigning(\n    transactionRequest: BTCTransactionRequest\n  ): Promise<{\n    transaction: BTCUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const publicKeyBuffer = Buffer.from(transactionRequest.publicKey, 'hex')\n    const psbt = await this.createPSBT({\n      transactionRequest,\n    })\n    // We can't double sign a PSBT, therefore we serialize the payload before to return it\n    const psbtHex = psbt.toHex()\n\n    const hashesToSign: HashToSign[] = []\n\n    const mockKeyPair = (index: number): bitcoin.Signer => ({\n      publicKey: publicKeyBuffer,\n      sign: (hash: Buffer): Buffer => {\n        hashesToSign[index] = Array.from(hash)\n        // Return dummy signature to satisfy the interface\n        return Buffer.alloc(64)\n      },\n    })\n\n    for (let index = 0; index < psbt.inputCount; index++) {\n      psbt.signInput(index, mockKeyPair(index))\n    }\n\n    return {\n      transaction: {\n        psbt: bitcoin.Psbt.fromHex(psbtHex),\n        publicKey: transactionRequest.publicKey,\n      },\n      hashesToSign,\n    }\n  }\n\n  finalizeTransactionSigning({\n    transaction: { psbt, publicKey },\n    rsvSignatures,\n  }: {\n    transaction: BTCUnsignedTransaction\n    rsvSignatures: RSVSignature[]\n  }): string {\n    const publicKeyBuffer = Buffer.from(publicKey, 'hex')\n\n    const keyPair = (index: number): bitcoin.Signer => ({\n      publicKey: publicKeyBuffer,\n      sign: () => {\n        const mpcSignature = rsvSignatures[index]\n        return Bitcoin.transformRSVSignature(mpcSignature)\n      },\n    })\n\n    for (let index = 0; index < psbt.inputCount; index++) {\n      psbt.signInput(index, keyPair(index))\n    }\n\n    psbt.finalizeAllInputs()\n    return psbt.extractTransaction().toHex()\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    const txId = await this.btcRpcAdapter.broadcastTransaction(txSerialized)\n    return { hash: txId }\n  }\n}\n","import type {\n  BTCTransaction,\n  BTCInput,\n  BTCOutput,\n} from '@chain-adapters/Bitcoin/types'\n\nexport abstract class BTCRpcAdapter {\n  abstract selectUTXOs(\n    from: string,\n    targets: BTCOutput[]\n  ): Promise<{ inputs: BTCInput[]; outputs: BTCOutput[] }>\n  abstract broadcastTransaction(transactionHex: string): Promise<string>\n  abstract getBalance(address: string): Promise<number>\n  abstract getTransaction(txid: string): Promise<BTCTransaction>\n}\n","// There is no types for coinselect\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-expect-error\n\nimport coinselect from 'coinselect'\n\nimport { BTCRpcAdapter } from '@chain-adapters/Bitcoin/BTCRpcAdapter/BTCRpcAdapter'\nimport {\n  type BTCFeeRecommendation,\n  type UTXO,\n} from '@chain-adapters/Bitcoin/BTCRpcAdapter/Mempool/types'\nimport type {\n  BTCTransaction,\n  BTCInput,\n  BTCOutput,\n} from '@chain-adapters/Bitcoin/types'\n\nexport class Mempool extends BTCRpcAdapter {\n  private readonly providerUrl: string\n\n  constructor(providerUrl: string) {\n    super()\n    this.providerUrl = providerUrl\n  }\n\n  private async fetchFeeRate(confirmationTarget = 6): Promise<number> {\n    const response = await fetch(`${this.providerUrl}/v1/fees/recommended`)\n    const data = (await response.json()) as BTCFeeRecommendation\n\n    if (confirmationTarget <= 1) {\n      return data.fastestFee\n    } else if (confirmationTarget <= 3) {\n      return data.halfHourFee\n    } else if (confirmationTarget <= 6) {\n      return data.hourFee\n    } else {\n      return data.economyFee\n    }\n  }\n\n  private async fetchUTXOs(address: string): Promise<UTXO[]> {\n    try {\n      const response = await fetch(\n        `${this.providerUrl}/address/${address}/utxo`\n      )\n      return (await response.json()) as UTXO[]\n    } catch (error) {\n      console.error('Failed to fetch UTXOs:', error)\n      return []\n    }\n  }\n\n  async selectUTXOs(\n    from: string,\n    targets: BTCOutput[],\n    confirmationTarget = 6\n  ): Promise<{ inputs: BTCInput[]; outputs: BTCOutput[] }> {\n    const utxos = await this.fetchUTXOs(from)\n    const feeRate = await this.fetchFeeRate(confirmationTarget)\n\n    // Add a small amount to the fee rate to ensure the transaction is confirmed\n    const ret = coinselect(utxos, targets, Math.ceil(feeRate + 1))\n\n    if (!ret.inputs || !ret.outputs) {\n      throw new Error(\n        'Invalid transaction: coinselect failed to find a suitable set of inputs and outputs. This could be due to insufficient funds, or no inputs being available that meet the criteria.'\n      )\n    }\n\n    return {\n      inputs: ret.inputs,\n      outputs: ret.outputs,\n    }\n  }\n\n  async broadcastTransaction(transactionHex: string): Promise<string> {\n    const response = await fetch(`${this.providerUrl}/tx`, {\n      method: 'POST',\n      body: transactionHex,\n    })\n\n    if (response.ok) {\n      return await response.text()\n    }\n\n    throw new Error(`Failed to broadcast transaction: ${await response.text()}`)\n  }\n\n  async getBalance(address: string): Promise<number> {\n    const response = await fetch(`${this.providerUrl}/address/${address}`)\n    const data = (await response.json()) as {\n      chain_stats: { funded_txo_sum: number; spent_txo_sum: number }\n    }\n    return data.chain_stats.funded_txo_sum - data.chain_stats.spent_txo_sum\n  }\n\n  async getTransaction(txid: string): Promise<BTCTransaction> {\n    const response = await fetch(`${this.providerUrl}/tx/${txid}`)\n    return (await response.json()) as BTCTransaction\n  }\n}\n","import { Mempool } from './Mempool'\nexport { BTCRpcAdapter } from './BTCRpcAdapter'\n\nexport const BTCRpcAdapters = {\n  Mempool,\n}\n","// Cosmos\nexport { Cosmos } from './Cosmos'\n\nexport type {\n  CosmosNetworkIds,\n  CosmosTransactionRequest,\n  CosmosUnsignedTransaction,\n} from './types'\n","import { encodeSecp256k1Pubkey } from '@cosmjs/amino'\nimport { ripemd160, sha256 } from '@cosmjs/crypto'\nimport { toBase64, fromBase64, fromHex } from '@cosmjs/encoding'\nimport {\n  Registry,\n  makeSignBytes,\n  encodePubkey,\n  makeAuthInfoBytes,\n  makeSignDoc,\n  type TxBodyEncodeObject,\n} from '@cosmjs/proto-signing'\nimport { GasPrice, StargateClient, calculateFee } from '@cosmjs/stargate'\nimport { bech32 } from 'bech32'\nimport { SignMode } from 'cosmjs-types/cosmos/tx/signing/v1beta1/signing'\nimport { TxRaw } from 'cosmjs-types/cosmos/tx/v1beta1/tx'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport type {\n  CosmosNetworkIds,\n  CosmosTransactionRequest,\n  CosmosUnsignedTransaction,\n  ChainInfo,\n  BalanceResponse,\n} from '@chain-adapters/Cosmos/types'\nimport { fetchChainInfo } from '@chain-adapters/Cosmos/utils'\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, RSVSignature, UncompressedPubKeySEC1 } from '@types'\nimport { cryptography } from '@utils'\n\n/**\n * Implementation of the ChainAdapter interface for Cosmos-based networks.\n * Handles interactions with Cosmos SDK chains like Cosmos Hub, Osmosis, etc.\n */\nexport class Cosmos extends ChainAdapter<\n  CosmosTransactionRequest,\n  CosmosUnsignedTransaction\n> {\n  private readonly registry: Registry\n  private readonly chainId: CosmosNetworkIds\n  private readonly contract: ChainSignatureContract\n  private readonly endpoints?: {\n    rpcUrl?: string\n    restUrl?: string\n  }\n\n  /**\n   * Creates a new Cosmos chain instance\n   * @param params - Configuration parameters\n   * @param params.chainId - Chain id for the Cosmos network\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   * @param params.endpoints - Optional RPC and REST endpoints\n   * @param params.endpoints.rpcUrl - Optional RPC endpoint URL\n   * @param params.endpoints.restUrl - Optional REST endpoint URL\n   */\n  constructor({\n    chainId,\n    contract,\n    endpoints,\n  }: {\n    contract: ChainSignatureContract\n    chainId: CosmosNetworkIds\n    endpoints?: {\n      rpcUrl?: string\n      restUrl?: string\n    }\n  }) {\n    super()\n\n    this.contract = contract\n    this.registry = new Registry()\n    this.chainId = chainId\n    this.endpoints = endpoints\n  }\n\n  private transformRSVSignature(rsvSignature: RSVSignature): Uint8Array {\n    return new Uint8Array([\n      ...fromHex(rsvSignature.r),\n      ...fromHex(rsvSignature.s),\n    ])\n  }\n\n  private async getChainInfo(): Promise<ChainInfo> {\n    return {\n      ...(await fetchChainInfo(this.chainId)),\n      ...this.endpoints,\n    }\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    try {\n      const { restUrl, denom, decimals } = await this.getChainInfo()\n\n      const response = await fetch(\n        `${restUrl}/cosmos/bank/v1beta1/balances/${address}`\n      )\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`)\n      }\n\n      const data = (await response.json()) as BalanceResponse\n      const balance = data.balances.find((b) => b.denom === denom)\n      const amount = balance?.amount ?? '0'\n\n      return {\n        balance: BigInt(amount),\n        decimals,\n      }\n    } catch (error) {\n      console.error('Failed to fetch Cosmos balance:', error)\n      throw new Error('Failed to fetch Cosmos balance')\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{\n    address: string\n    publicKey: string\n  }> {\n    const { prefix } = await this.getChainInfo()\n    const uncompressedPubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n    })\n\n    if (!uncompressedPubKey) {\n      throw new Error('Failed to get derived public key')\n    }\n\n    const derivedKey = cryptography.compressPubKey(\n      uncompressedPubKey as UncompressedPubKeySEC1\n    )\n    const pubKeySha256 = sha256(fromHex(derivedKey))\n    const ripemd160Hash = ripemd160(pubKeySha256)\n    const address = bech32.encode(prefix, bech32.toWords(ripemd160Hash))\n\n    return { address, publicKey: derivedKey }\n  }\n\n  serializeTransaction(transaction: CosmosUnsignedTransaction): string {\n    const serialized = TxRaw.encode(transaction).finish()\n    return toBase64(serialized)\n  }\n\n  deserializeTransaction(serialized: string): CosmosUnsignedTransaction {\n    return TxRaw.decode(fromBase64(serialized))\n  }\n\n  async prepareTransactionForSigning(\n    transactionRequest: CosmosTransactionRequest\n  ): Promise<{\n    transaction: CosmosUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const { denom, rpcUrl, gasPrice } = await this.getChainInfo()\n    const publicKeyBytes = fromHex(transactionRequest.publicKey)\n\n    const gasLimit = transactionRequest.gas || 200_000\n\n    const fee = calculateFee(\n      gasLimit,\n      GasPrice.fromString(`${gasPrice}${denom}`)\n    )\n\n    const client = await StargateClient.connect(rpcUrl)\n    const accountOnChain = await client.getAccount(transactionRequest.address)\n    if (!accountOnChain) {\n      throw new Error(\n        `Account ${transactionRequest.address} does not exist on chain`\n      )\n    }\n\n    const { accountNumber, sequence } = accountOnChain\n\n    const txBodyEncodeObject: TxBodyEncodeObject = {\n      typeUrl: '/cosmos.tx.v1beta1.TxBody',\n      value: {\n        messages: transactionRequest.messages,\n        memo: transactionRequest.memo || '',\n      },\n    }\n\n    const txBodyBytes = this.registry.encode(txBodyEncodeObject)\n\n    const pubkey = encodePubkey(encodeSecp256k1Pubkey(publicKeyBytes))\n\n    // TODO: Allow caller to provide: multiple signers, fee payer, fee granter\n    const authInfoBytes = makeAuthInfoBytes(\n      [\n        {\n          pubkey,\n          sequence,\n        },\n      ],\n      fee.amount,\n      Number(fee.gas),\n      undefined,\n      undefined,\n      SignMode.SIGN_MODE_DIRECT\n    )\n\n    const signDoc = makeSignDoc(\n      txBodyBytes,\n      authInfoBytes,\n      this.chainId,\n      accountNumber\n    )\n\n    const signBytes = makeSignBytes(signDoc)\n    const payload = Array.from(sha256(signBytes))\n\n    return {\n      transaction: TxRaw.fromPartial({\n        bodyBytes: txBodyBytes,\n        authInfoBytes,\n        signatures: [],\n      }),\n      hashesToSign: [payload],\n    }\n  }\n\n  finalizeTransactionSigning({\n    transaction,\n    rsvSignatures,\n  }: {\n    transaction: CosmosUnsignedTransaction\n    rsvSignatures: RSVSignature[]\n  }): string {\n    // Allow support for multi-sig but the package only supports single-sig\n    transaction.signatures = rsvSignatures.map((sig) =>\n      this.transformRSVSignature(sig)\n    )\n\n    const txBytes = TxRaw.encode(transaction).finish()\n    return Buffer.from(txBytes).toString('hex')\n  }\n\n  // @ts-expect-error - TODO: fix this\n  async broadcastTx(txSerialized: string): Promise<string> {\n    try {\n      const { rpcUrl } = await this.getChainInfo()\n      const client = await StargateClient.connect(rpcUrl)\n\n      const txBytes = fromHex(txSerialized)\n      const broadcastResponse = await client.broadcastTx(txBytes)\n\n      if (broadcastResponse.code !== 0) {\n        throw new Error(`Broadcast error: ${broadcastResponse.rawLog}`)\n      }\n\n      return broadcastResponse.transactionHash\n    } catch (error) {\n      console.error('Transaction broadcast failed:', error)\n      throw new Error('Failed to broadcast transaction.')\n    }\n  }\n}\n","import { chains, assets } from 'chain-registry'\n\nimport { type ChainInfo } from '@chain-adapters/Cosmos/types'\n\nexport const fetchChainInfo = async (chainId: string): Promise<ChainInfo> => {\n  const chainInfo = chains.find((chain) => chain.chain_id === chainId)\n  if (!chainInfo) {\n    throw new Error(`Chain info not found for chainId: ${chainId}`)\n  }\n\n  const { bech32_prefix: prefix, chain_id: expectedChainId } = chainInfo\n  const denom = chainInfo.staking?.staking_tokens?.[0]?.denom\n  const rpcUrl = chainInfo.apis?.rpc?.[0]?.address\n  const restUrl = chainInfo.apis?.rest?.[0]?.address\n  const gasPrice = chainInfo.fees?.fee_tokens?.[0]?.average_gas_price\n\n  if (\n    !prefix ||\n    !denom ||\n    !rpcUrl ||\n    !restUrl ||\n    !expectedChainId ||\n    gasPrice === undefined\n  ) {\n    throw new Error(\n      `Missing required chain information for ${chainInfo.chain_name}`\n    )\n  }\n\n  const assetList = assets.find(\n    (asset) => asset.chain_name === chainInfo.chain_name\n  )\n  const asset = assetList?.assets.find((asset) => asset.base === denom)\n  const decimals = asset?.denom_units.find(\n    (unit) => unit.denom === asset.display\n  )?.exponent\n\n  if (decimals === undefined) {\n    throw new Error(\n      `Could not find decimals for ${denom} on chain ${chainInfo.chain_name}`\n    )\n  }\n\n  return { prefix, denom, rpcUrl, restUrl, expectedChainId, gasPrice, decimals }\n}\n","export * from './Solana'\nexport * from './types'\n","import type { Connection as SolanaConnection } from '@solana/web3.js'\nimport { PublicKey, Transaction, SystemProgram } from '@solana/web3.js'\nimport type BN from 'bn.js'\n\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, Signature } from '@types'\n\nimport { ChainAdapter } from '../ChainAdapter'\n\nimport type {\n  SolanaTransactionRequest,\n  SolanaUnsignedTransaction,\n} from './types'\n\nconst toBigInt = (value: bigint | BN): bigint => {\n  if (typeof value === 'bigint') return value\n  return BigInt(value.toString())\n}\n\nexport class Solana extends ChainAdapter<\n  SolanaTransactionRequest,\n  SolanaUnsignedTransaction\n> {\n  private readonly connection: SolanaConnection\n  private readonly contract: ChainSignatureContract\n\n  constructor(args: {\n    solanaConnection: SolanaConnection\n    contract: ChainSignatureContract\n  }) {\n    super()\n    this.connection = args.solanaConnection\n    this.contract = args.contract\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const pubkey = new PublicKey(address)\n    const balance = await this.connection.getBalance(pubkey)\n    return {\n      balance: BigInt(balance),\n      decimals: 9, // Solana uses 9 decimals (LAMPORTS_PER_SOL)\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const pubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n      IsEd25519: true,\n    })\n\n    console.log('[chainsig.js] getDerivedPublicKey returned:', pubKey)\n    const base58Key = pubKey.replace('ed25519:', '')\n    console.log('[chainsig.js] after replace, base58Key:', base58Key)\n    const publicKey = new PublicKey(base58Key)\n\n    return {\n      address: publicKey.toBase58(),\n      publicKey: publicKey.toString(),\n    }\n  }\n\n  serializeTransaction(transaction: SolanaUnsignedTransaction): string {\n    return Buffer.from(\n      transaction.transaction.serialize({\n        requireAllSignatures: false,\n      })\n    ).toString('base64')\n  }\n\n  deserializeTransaction(serialized: string): SolanaUnsignedTransaction {\n    const buffer = Buffer.from(serialized, 'base64')\n    const transaction = Transaction.from(buffer)\n\n    return {\n      transaction,\n      feePayer:\n        transaction.feePayer ||\n        new PublicKey('11111111111111111111111111111111'),\n      recentBlockhash: transaction.recentBlockhash || '',\n    }\n  }\n\n  async prepareTransactionForSigning(\n    request: SolanaTransactionRequest\n  ): Promise<{\n    transaction: SolanaUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const transaction = new Transaction()\n\n    // Add transfer instruction if amount is specified\n    const amount = toBigInt(request.amount)\n    if (amount > 0n) {\n      transaction.add(\n        SystemProgram.transfer({\n          fromPubkey: new PublicKey(request.from),\n          toPubkey: new PublicKey(request.to),\n          lamports: Number(amount),\n        })\n      )\n    }\n\n    // Add any additional instructions\n    if (request.instructions) {\n      transaction.add(...request.instructions)\n    }\n\n    // Get recent blockhash\n    const { blockhash } = await this.connection.getLatestBlockhash()\n    transaction.recentBlockhash = blockhash\n\n    // Set fee payer\n    transaction.feePayer = request.feePayer || new PublicKey(request.from)\n\n    const messageBytes = transaction.compileMessage().serialize()\n\n    return {\n      transaction: {\n        transaction,\n        feePayer: transaction.feePayer,\n        recentBlockhash: blockhash,\n      },\n      hashesToSign: [Array.from(messageBytes)],\n    }\n  }\n\n  finalizeTransactionSigning({\n    transaction,\n    rsvSignatures,\n    senderAddress,\n  }: {\n    transaction: Transaction\n    rsvSignatures: Signature\n    senderAddress: string\n  }): string {\n    const signatureBuffer = Buffer.from(rsvSignatures.signature)\n    transaction.addSignature(new PublicKey(senderAddress), signatureBuffer)\n    return transaction.serialize().toString('base64')\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    const transaction = this.deserializeTransaction(txSerialized)\n\n    const signature = await this.connection.sendRawTransaction(\n      transaction.transaction.serialize()\n    )\n\n    return { hash: signature }\n  }\n}\n","export { Aptos } from './Aptos'\n","import {\n  type AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  type AnyRawTransaction,\n  Deserializer,\n  Ed25519PublicKey,\n  Ed25519Signature,\n  generateSigningMessageForTransaction,\n  MultiAgentTransaction,\n  SimpleTransaction,\n  type Aptos as _Aptos,\n  type PendingTransactionResponse,\n  generateSignedTransaction,\n  postAptosFullNode,\n  SignedTransaction,\n  MimeType,\n  AbstractKeylessAccount,\n  KeylessPublicKey,\n  FederatedKeylessPublicKey,\n  type KeylessSignature,\n} from '@aptos-labs/ts-sdk'\nimport bs58 from 'bs58'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport { type ChainSignatureContract } from '@contracts'\nimport { type HashToSign, type Signature } from '@types'\n\nexport class Aptos extends ChainAdapter<AnyRawTransaction, AnyRawTransaction> {\n  private readonly contract: ChainSignatureContract\n  private readonly client: _Aptos\n\n  /**\n   * Creates a new Aptos chain instance\n   * @param params - Configuration parameters\n   * @param params.client - A Aptos client instance to interact with the blockchain\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   */\n  constructor({\n    contract,\n    client,\n  }: {\n    contract: ChainSignatureContract\n    client: _Aptos\n  }) {\n    super()\n\n    this.contract = contract\n    this.client = client\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const amount = await this.client.account.getAccountAPTAmount({\n      accountAddress: address,\n    })\n\n    return {\n      balance: BigInt(amount),\n      decimals: 8,\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const pubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n      IsEd25519: true,\n    })\n\n    const base58Key = pubKey.replace('ed25519:', '')\n    const bytes = bs58.decode(base58Key)\n    const publicKey = '0x' + Buffer.from(bytes).toString('hex')\n    const address = new Ed25519PublicKey(bytes)\n      .authKey()\n      .derivedAddress()\n      .toString()\n\n    return {\n      address,\n      publicKey,\n    }\n  }\n\n  serializeTransaction(transaction: AnyRawTransaction): string {\n    return transaction.bcsToHex().toString()\n  }\n\n  deserializeTransaction(\n    serialized: string\n  ): MultiAgentTransaction | SimpleTransaction {\n    const isPrefixWith0x = serialized.startsWith('0x')\n\n    const buffer = Buffer.from(\n      isPrefixWith0x ? serialized.slice(2) : serialized,\n      'hex'\n    )\n    try {\n      const deserializer = new Deserializer(buffer)\n      return MultiAgentTransaction.deserialize(deserializer)\n    } catch {\n      // failed to deserialize as MultiAgentTransaction\n      // try multi agent next\n    }\n\n    const deserializer = new Deserializer(buffer)\n    return SimpleTransaction.deserialize(deserializer)\n  }\n\n  async prepareTransactionForSigning(\n    transactionRequest: AnyRawTransaction\n  ): Promise<{ transaction: AnyRawTransaction; hashesToSign: HashToSign[] }> {\n    return {\n      transaction: transactionRequest,\n      hashesToSign: [generateSigningMessageForTransaction(transactionRequest)],\n    }\n  }\n\n  rsvSignatureToSenderAuthenticator(params: {\n    rsvSignatures: Signature\n    publicKey: string\n  }): AccountAuthenticatorEd25519 {\n    const signatureBuffer = Buffer.from(params.rsvSignatures.signature)\n\n    const isPublicKeyPrefixWith0x = params.publicKey.startsWith('0x')\n\n    const publicKeyBuffer = Buffer.from(\n      isPublicKeyPrefixWith0x ? params.publicKey.slice(2) : params.publicKey,\n      'hex'\n    )\n\n    const publicKey = new Ed25519PublicKey(publicKeyBuffer)\n\n    const senderAuthenticator = new AccountAuthenticatorEd25519(\n      publicKey,\n      new Ed25519Signature(signatureBuffer.toString('hex'))\n    )\n\n    return senderAuthenticator\n  }\n\n  finalizeTransactionSigning(params: {\n    transaction: AnyRawTransaction\n    rsvSignatures: Signature\n    publicKey: string\n    additionalSignersAuthenticators?: AccountAuthenticator[]\n    feePayerAuthenticator?: AccountAuthenticator\n  }): string {\n    const senderAuthenticator = this.rsvSignatureToSenderAuthenticator({\n      rsvSignatures: params.rsvSignatures,\n      publicKey: params.publicKey,\n    })\n\n    const signedTx = generateSignedTransaction({\n      transaction: params.transaction,\n      senderAuthenticator,\n      additionalSignersAuthenticators: params.additionalSignersAuthenticators,\n      feePayerAuthenticator: params.feePayerAuthenticator,\n    })\n\n    return '0x' + Buffer.from(signedTx).toString('hex')\n  }\n\n  private deserializeSignedTransaction(\n    serializedSignedTransaction: string\n  ): SignedTransaction {\n    const isPrefixWith0x = serializedSignedTransaction.startsWith('0x')\n    const buffer = Buffer.from(\n      isPrefixWith0x\n        ? serializedSignedTransaction.slice(2)\n        : serializedSignedTransaction,\n      'hex'\n    )\n\n    const deserializer = new Deserializer(buffer)\n\n    const signedTransaction = SignedTransaction.deserialize(deserializer)\n\n    return signedTransaction\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    // copy from aptos-ts-sdk, `transactionSubmission.ts` -> `submitTransaction()`\n    const signedTransaction = this.deserializeSignedTransaction(txSerialized)\n\n    try {\n      const { data } = await postAptosFullNode<\n        Uint8Array,\n        PendingTransactionResponse\n      >({\n        aptosConfig: this.client.config,\n        body: signedTransaction.bcsToBytes(),\n        path: 'transactions',\n        originMethod: 'submitTransaction',\n        contentType: MimeType.BCS_SIGNED_TRANSACTION,\n      })\n\n      return {\n        hash: data.hash,\n      }\n    } catch (e) {\n      if (\n        signedTransaction.authenticator.isSingleSender() &&\n        signedTransaction.authenticator.sender.isSingleKey() &&\n        (signedTransaction.authenticator.sender.public_key.publicKey instanceof\n          KeylessPublicKey ||\n          signedTransaction.authenticator.sender.public_key.publicKey instanceof\n            FederatedKeylessPublicKey)\n      ) {\n        await AbstractKeylessAccount.fetchJWK({\n          aptosConfig: this.client.config,\n          publicKey:\n            signedTransaction.authenticator.sender.public_key.publicKey,\n          kid: (\n            signedTransaction.authenticator.sender.signature\n              .signature as KeylessSignature\n          ).getJwkKid(),\n        })\n      }\n      throw e\n    }\n  }\n}\n","export * from './SUI'\nexport * from './types'\n","import { toBase64 } from '@mysten/bcs'\nimport {\n  type SuiClient,\n  SuiHTTPTransport,\n  type SuiTransactionBlockResponse,\n} from '@mysten/sui/client'\nimport {\n  messageWithIntent,\n  toSerializedSignature,\n} from '@mysten/sui/cryptography'\nimport { Ed25519PublicKey } from '@mysten/sui/keypairs/ed25519'\nimport { type Transaction } from '@mysten/sui/transactions'\nimport { blake2b } from '@noble/hashes/blake2b'\nimport bs58 from 'bs58'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport { type ChainSignatureContract } from '@contracts'\nimport { type HashToSign, type Signature } from '@types'\n\nimport {\n  type SUITransactionRequest,\n  type SUIUnsignedTransaction,\n} from './types'\n\nexport class SUI extends ChainAdapter<\n  SUITransactionRequest,\n  SUIUnsignedTransaction\n> {\n  private readonly contract: ChainSignatureContract\n  private readonly client: SuiClient\n  private readonly transport: SuiHTTPTransport\n  /**\n   * Creates a new SUI chain instance\n   * @param params - Configuration parameters\n   * @param params.client - A SUI client instance to interact with the blockchain\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   */\n  constructor({\n    contract,\n    client,\n    rpcUrl,\n  }: {\n    contract: ChainSignatureContract\n    client: SuiClient\n    rpcUrl: string\n  }) {\n    super()\n\n    this.contract = contract\n    this.client = client\n    this.transport = new SuiHTTPTransport({ url: rpcUrl })\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const balance = await this.client.getBalance({\n      owner: address,\n    })\n\n    return {\n      balance: BigInt(balance.totalBalance),\n      decimals: 9,\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const pubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n      IsEd25519: true,\n    })\n\n    const base58Key = pubKey.replace('ed25519:', '')\n    const bytes = bs58.decode(base58Key)\n\n    const pubKeyInSui = new Ed25519PublicKey(bytes)\n\n    return {\n      publicKey: pubKeyInSui.toSuiPublicKey(),\n      address: pubKeyInSui.toSuiAddress(),\n    }\n  }\n\n  serializeTransaction(transaction: Uint8Array<ArrayBufferLike>): string {\n    return Buffer.from(transaction).toString('hex')\n  }\n\n  deserializeTransaction(serialized: string): Uint8Array<ArrayBufferLike> {\n    const buffer = Buffer.from(serialized, 'hex')\n    return new Uint8Array(buffer)\n  }\n\n  async prepareTransactionForSigning(transactionRequest: Transaction): Promise<{\n    transaction: Uint8Array<ArrayBufferLike>\n    hashesToSign: HashToSign[]\n  }> {\n    const txBytes = await transactionRequest.build({\n      client: this.client,\n    })\n    const intent = 'TransactionData'\n\n    const intentMessage = messageWithIntent(intent, txBytes)\n    const digest = blake2b(intentMessage, { dkLen: 32 })\n\n    return {\n      hashesToSign: [digest],\n      transaction: txBytes,\n    }\n  }\n\n  rsvSignatureToSuiSignature(params: {\n    transaction: Uint8Array<ArrayBufferLike>\n    rsvSignatures: Signature\n    publicKey: string\n  }): string {\n    const publicKeyBufferWithPrefix = Buffer.from(params.publicKey, 'base64')\n    const rawPublicKeyBuffer = publicKeyBufferWithPrefix.subarray(1)\n    const signature = toSerializedSignature({\n      signature: Buffer.from(params.rsvSignatures.signature),\n      signatureScheme: 'ED25519',\n      publicKey: new Ed25519PublicKey(rawPublicKeyBuffer),\n    })\n\n    return signature\n  }\n\n  finalizeTransactionSigning(params: {\n    transaction: Uint8Array<ArrayBufferLike>\n    rsvSignatures: Signature\n    publicKey: string\n  }): string {\n    const signature = this.rsvSignatureToSuiSignature(params)\n\n    // doing this as SUI dont have a way to serialize\n    // signature and transaction\n    return JSON.stringify([\n      typeof params.transaction === 'string'\n        ? params.transaction\n        : toBase64(params.transaction),\n      Array.isArray(signature) ? signature : [signature],\n    ])\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    const result: SuiTransactionBlockResponse = await this.transport.request({\n      method: 'sui_executeTransactionBlock',\n      params: JSON.parse(txSerialized),\n    })\n\n    return {\n      hash: result.digest,\n    }\n  }\n}\n","export { XRP } from './XRP'\n\nexport type { XRPTransactionRequest, XRPUnsignedTransaction } from './types'\n","import { createHash } from 'node:crypto'\n\nimport { encodeAccountID } from 'ripple-address-codec'\nimport { encode as encodeTx } from 'ripple-binary-codec'\nimport { Client } from 'xrpl'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, RSVSignature, UncompressedPubKeySEC1 } from '@types'\nimport { cryptography } from '@utils'\n\nimport type { XRPTransactionRequest, XRPUnsignedTransaction } from './types'\n\n/**\n * XRP Ledger chain adapter implementation\n *\n * Provides functionality to interact with the XRP Ledger blockchain including\n * balance queries, address derivation, transaction preparation, signing, and broadcasting.\n */\nexport class XRP extends ChainAdapter<\n  XRPTransactionRequest,\n  XRPUnsignedTransaction\n> {\n  private readonly rpcUrl: string\n  private readonly contract: ChainSignatureContract\n  private readonly client: Client\n\n  /**\n   * Creates a new XRP chain adapter instance\n   *\n   * @param params - Configuration parameters\n   * @param params.rpcUrl - XRP Ledger RPC endpoint URL\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   * @param params.client - Optional XRPL client instance (for testing)\n   */\n  constructor({\n    rpcUrl,\n    contract,\n    client,\n  }: {\n    rpcUrl: string\n    contract: ChainSignatureContract\n    client?: Client\n  }) {\n    super()\n\n    this.rpcUrl = rpcUrl\n    this.contract = contract\n    this.client = client || new Client(this.rpcUrl)\n  }\n\n  /**\n   * Retrieves the XRP balance for a given address\n   *\n   * @param address - The XRP address to query\n   * @returns Promise resolving to balance information with amount in drops and decimal places\n   * @throws Error if the balance query fails for reasons other than account not found\n   */\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    try {\n      await this.client.connect()\n\n      const response = await this.client.request({\n        command: 'account_info',\n        account: address,\n        ledger_index: 'validated',\n      })\n\n      const balance = BigInt(String(response?.result?.account_data?.Balance))\n\n      return {\n        balance: balance || 0n,\n        decimals: 6,\n      }\n    } catch (error: any) {\n      // Handle account not found errors\n      if (\n        error?.data?.error === 'actNotFound' ||\n        error?.message?.includes('Account not found') ||\n        error?.data?.error_message?.includes('Account not found')\n      ) {\n        return {\n          balance: 0n,\n          decimals: 6,\n        }\n      }\n\n      console.error('Failed to fetch XRP balance:', error)\n      throw new Error('Failed to fetch XRP balance')\n    } finally {\n      // Always disconnect in finally block to ensure cleanup\n      try {\n        await this.client.disconnect()\n      } catch (disconnectError) {\n        console.warn('Error disconnecting XRP client:', disconnectError)\n      }\n    }\n  }\n\n  /**\n   * Derives an XRP address and compressed public key from the given path and predecessor\n   *\n   * @param predecessor - The predecessor for key derivation\n   * @param path - The derivation path\n   * @returns Promise resolving to the derived address and compressed public key\n   * @throws Error if public key derivation fails\n   */\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const uncompressedPubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n    })\n\n    if (!uncompressedPubKey) {\n      throw new Error('Failed to get derived secp256k1 public key')\n    }\n\n    const compressedPubKey = cryptography.compressPubKey(\n      uncompressedPubKey as UncompressedPubKeySEC1\n    )\n\n    const address = this.deriveXRPAddress(compressedPubKey)\n\n    return {\n      address,\n      publicKey: compressedPubKey,\n    }\n  }\n\n  /**\n   * Derives an XRP address from a compressed secp256k1 public key\n   *\n   * @param publicKeyHex - The compressed secp256k1 public key in hex format (66 chars: 02/03 + 64)\n   * @returns The XRP address encoded using ripple-address-codec\n   */\n  private deriveXRPAddress(publicKeyHex: string): string {\n    const publicKeyBuffer = Buffer.from(publicKeyHex, 'hex')\n    const sha256Hash = createHash('sha256').update(publicKeyBuffer).digest()\n    const ripemd160Hash = createHash('ripemd160').update(sha256Hash).digest()\n    const address = encodeAccountID(ripemd160Hash)\n\n    return address\n  }\n\n  /**\n   * Serializes an XRP unsigned transaction to a JSON string\n   *\n   * @param transaction - The unsigned transaction to serialize\n   * @returns JSON string representation of the transaction\n   */\n  serializeTransaction(transaction: XRPUnsignedTransaction): string {\n    return JSON.stringify(transaction)\n  }\n\n  /**\n   * Deserializes a JSON string back to an XRP unsigned transaction\n   *\n   * @param serialized - The JSON string to deserialize\n   * @returns The deserialized unsigned transaction\n   */\n  deserializeTransaction(serialized: string): XRPUnsignedTransaction {\n    return JSON.parse(serialized)\n  }\n\n  /**\n   * Prepares an XRP transaction for signing by autofilling required fields and generating signing hash\n   *\n   * @param transactionRequest - The transaction request containing payment details\n   * @returns Promise resolving to the prepared unsigned transaction and hash to sign\n   * @throws Error if transaction preparation fails\n   */\n  async prepareTransactionForSigning(\n    transactionRequest: XRPTransactionRequest\n  ): Promise<{\n    transaction: XRPUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    try {\n      await this.client.connect()\n\n      const signingPubKey = transactionRequest.publicKey\n      const prepared = await this.client.autofill({\n        TransactionType: 'Payment',\n        Account: transactionRequest.from,\n        Destination: transactionRequest.to,\n        Amount: transactionRequest.amount,\n        SigningPubKey: signingPubKey.toUpperCase(),\n      })\n\n      // Don't disconnect here - allow connection reuse\n\n      const unsignedTx: XRPUnsignedTransaction = {\n        transaction: prepared as any,\n        signingPubKey,\n      }\n\n      const encodedTx = encodeTx(prepared)\n\n      const signingPrefix = new Uint8Array([0x53, 0x54, 0x58, 0x00])\n      const encodedBytes = new Uint8Array(Buffer.from(encodedTx, 'hex'))\n\n      const signingData = new Uint8Array(\n        signingPrefix.length + encodedBytes.length\n      )\n      signingData.set(signingPrefix, 0)\n      signingData.set(encodedBytes, signingPrefix.length)\n\n      const hash = createHash('sha512').update(signingData).digest()\n      const signingHash = new Uint8Array(hash.subarray(0, 32))\n\n      return {\n        transaction: unsignedTx,\n        hashesToSign: [signingHash],\n      }\n    } catch (error) {\n      console.error('Failed to prepare XRP transaction for signing:', error)\n      throw new Error('Failed to prepare XRP transaction for signing')\n    }\n  }\n\n  /**\n   * Finalizes transaction signing by applying RSV signatures to the prepared transaction\n   *\n   * @param params - Object containing the unsigned transaction and RSV signatures\n   * @param params.transaction - The unsigned transaction to sign\n   * @param params.rsvSignatures - Array of RSV signatures (only first signature is used)\n   * @returns JSON string of the signed transaction ready for broadcast\n   * @throws Error if no signatures are provided\n   */\n  finalizeTransactionSigning({\n    transaction,\n    rsvSignatures,\n  }: {\n    transaction: XRPUnsignedTransaction\n    rsvSignatures: RSVSignature[]\n  }): string {\n    if (rsvSignatures.length === 0) {\n      throw new Error('Invalid signatures provided')\n    }\n\n    const signature = rsvSignatures[0]\n\n    const derSignature = this.generateTxnSignature(\n      signature.r,\n      signature.s,\n      signature.v\n    )\n\n    const signedTransaction = {\n      ...transaction.transaction,\n      TxnSignature: derSignature,\n      SigningPubKey: transaction.signingPubKey.toUpperCase(),\n    }\n\n    return JSON.stringify(signedTransaction)\n  }\n\n  /**\n   * Generates a DER-encoded transaction signature from RSV signature components\n   *\n   * @param r - The R component of the signature in hex\n   * @param s - The S component of the signature in hex\n   * @param v - The V component of the signature (recovery ID)\n   * @returns DER-encoded signature in uppercase hex format\n   */\n  generateTxnSignature(r: string, s: string, v: number): string {\n    const rBuf = Buffer.from(r, 'hex')\n    const sBuf = Buffer.from(s, 'hex')\n    let rVal = rBuf\n    if (rBuf[0] > 0x7f) {\n      rVal = Buffer.concat([Buffer.from([0x00]), rBuf])\n    }\n\n    let sVal = sBuf\n    if (sBuf[0] > 0x7f) {\n      sVal = Buffer.concat([Buffer.from([0x00]), sBuf])\n    }\n\n    const totalLength = 2 + rVal.length + 2 + sVal.length\n\n    const derSignature = Buffer.alloc(2 + totalLength)\n    let offset = 0\n\n    derSignature.writeUInt8(0x30, offset++)\n    derSignature.writeUInt8(totalLength, offset++)\n    derSignature.writeUInt8(0x02, offset++)\n    derSignature.writeUInt8(rVal.length, offset++)\n    rVal.copy(derSignature, offset)\n    offset += rVal.length\n\n    derSignature.writeUInt8(0x02, offset++)\n    derSignature.writeUInt8(sVal.length, offset++)\n    sVal.copy(derSignature, offset)\n\n    return derSignature.toString('hex').toUpperCase()\n  }\n\n  /**\n   * Broadcasts a signed XRP transaction to the network\n   *\n   * @param txSerialized - JSON string of the signed transaction\n   * @returns Promise resolving to the transaction hash\n   * @throws Error if transaction submission fails or is rejected by the network\n   */\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    try {\n      await this.client.connect()\n\n      const transaction = JSON.parse(txSerialized) as Record<string, unknown>\n\n      const txBlob = encodeTx(transaction)\n      const response = await this.client.submit(txBlob)\n\n      await this.client.disconnect()\n\n      if (\n        response.result.engine_result === 'tesSUCCESS' ||\n        response.result.engine_result === 'terQUEUED'\n      ) {\n        const txHash = response.result.tx_json?.hash\n        if (!txHash) {\n          throw new Error('Transaction submitted but no hash received')\n        }\n        return { hash: txHash }\n      } else {\n        throw new Error(\n          `Transaction failed: ${response.result.engine_result} - ${response.result.engine_result === 'terQUEUED' ? 'Transaction is queued' : response.result.engine_result}`\n        )\n      }\n    } catch (error) {\n      console.error('Failed to broadcast XRP transaction:', error)\n      throw new Error('Failed to broadcast XRP transaction')\n    }\n  }\n}\n","export { NEAR } from './NEAR'\nexport type { NearTransactionRequest, NearUnsignedTransaction } from './types'\nexport * as utils from './utils'\n\n ","import {\n  Transaction as NearTransaction,\n  SignedTransaction as NearSignedTransaction,\n  createTransaction as nearCreateTransaction,\n  encodeTransaction as nearEncodeTransaction,\n  Action as NearAction,\n  Transfer as NearTransfer,\n  Signature as NearSignature,\n} from '@near-js/transactions'\nimport { PublicKey as NearPublicKey } from '@near-js/crypto'\nimport { baseDecode } from '@near-js/utils'\nimport { JsonRpcProvider } from '@near-js/providers'\n\n// Cross-runtime SHA-256 (browser & Node)\nconst sha256Bytes = async (data: Uint8Array): Promise<Uint8Array> => {\n  const cryptoAny = (globalThis as any).crypto\n  if (cryptoAny && cryptoAny.subtle) {\n    const digest = await cryptoAny.subtle.digest('SHA-256', data)\n    return new Uint8Array(digest)\n  }\n  const { createHash } = await import('node:crypto')\n  return new Uint8Array(createHash('sha256').update(data).digest())\n}\n\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, Signature, RSVSignature } from '@types'\nimport type { Transaction as SolanaTransaction } from '@solana/web3.js'\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\n\nimport type { NearTransactionRequest, NearUnsignedTransaction } from './types'\n\nexport class NEAR extends ChainAdapter<NearTransactionRequest, NearUnsignedTransaction> {\n  private readonly provider: JsonRpcProvider\n  private readonly contract: ChainSignatureContract\n  private readonly networkId: 'mainnet' | 'testnet'\n\n  constructor(args: { rpcUrl: string; networkId: 'mainnet' | 'testnet'; contract: ChainSignatureContract }) {\n    super()\n    this.provider = new JsonRpcProvider({ url: args.rpcUrl })\n    this.contract = args.contract\n    this.networkId = args.networkId\n  }\n\n  private isAccountDoesNotExistError(error: unknown): boolean {\n    const msg = (error as any)?.message?.toString?.() || ''\n    const type = (error as any)?.type?.toString?.() || ''\n    return type === 'AccountDoesNotExist' || msg.includes('AccountDoesNotExist') || msg.includes(\"doesn't exist\") || msg.includes('does not exist')\n  }\n\n  async getBalance(address: string): Promise<{ balance: bigint; decimals: number }> {\n    try {\n      const res = (await this.provider.query<any>(`account/${address}`, '')) as any\n      return { balance: BigInt(res.amount), decimals: 24 }\n    } catch (e) {\n      if (this.isAccountDoesNotExistError(e)) {\n        throw new Error(\n          `NEAR derived account not found: ${address}. Create & fund it or call chainAdapters.near.utils.ensureDerivedAccountExists(...) before sending.`\n        )\n      }\n      throw e\n    }\n  }\n\n  async deriveAddressAndPublicKey(predecessor: string, path: string): Promise<{ address: string; publicKey: string }> {\n    const derivedKey = await this.contract.getDerivedPublicKey({ path, predecessor, IsEd25519: true })\n    const pk = NearPublicKey.fromString(derivedKey as string)\n    const derivedAccountId = `${path}.${predecessor}`\n    return { address: derivedAccountId, publicKey: pk.toString() }\n  }\n\n  serializeTransaction(unsigned: NearUnsignedTransaction): string {\n    const bytes = nearEncodeTransaction(unsigned.transaction)\n    return Buffer.from(bytes).toString('base64')\n  }\n\n  deserializeTransaction(serialized: string): NearUnsignedTransaction {\n    const buffer = Buffer.from(serialized, 'base64')\n    const tx = NearTransaction.decode(buffer)\n    return { transaction: tx }\n  }\n\n  async prepareTransactionForSigning(request: NearTransactionRequest): Promise<{ transaction: NearUnsignedTransaction; hashesToSign: HashToSign[] }> {\n    const { from, to, amount, publicKey } = request\n    let accessKey: any\n    try {\n      accessKey = (await this.provider.query<any>(`access_key/${from}/${publicKey}`, '')) as any\n    } catch (e) {\n      if (this.isAccountDoesNotExistError(e)) {\n        throw new Error(\n          `NEAR derived account not found: ${from}. Create & fund it or call chainAdapters.near.utils.ensureDerivedAccountExists({ derivedAccountId: \"${from}\", mpcPublicKey: \"${publicKey}\" }).`\n        )\n      }\n      throw e\n    }\n    const block = await this.provider.block({ finality: 'final' })\n    const recentBlockHash = baseDecode((accessKey?.block_hash as string) ?? block.header.hash)\n    const txPublicKey = NearPublicKey.fromString(accessKey?.public_key ? accessKey.public_key : publicKey)\n    const nextNonce: number = accessKey?.nonce ? accessKey.nonce + 1 : 1\n    const actions = [new NearAction({ transfer: new NearTransfer({ deposit: BigInt(amount) }) })]\n    const tx = nearCreateTransaction(from, txPublicKey, to, nextNonce, actions, recentBlockHash)\n    const serialized = nearEncodeTransaction(tx)\n    const hash = await sha256Bytes(serialized)\n    return { transaction: { transaction: tx }, hashesToSign: [Array.from(hash)] }\n  }\n\n  finalizeTransactionSigning({ transaction, rsvSignatures }: { transaction: NearUnsignedTransaction | SolanaTransaction; rsvSignatures: RSVSignature[] | Signature }): string {\n    if (Array.isArray(rsvSignatures)) throw new Error('NEAR expects an Ed25519 signature object, not RSV array')\n    const signatureBytes = Buffer.from(rsvSignatures.signature)\n    const txObj = 'transaction' in (transaction as any) ? (transaction as NearUnsignedTransaction).transaction : (transaction as any)\n    const signedTransaction = new NearSignedTransaction({ transaction: txObj, signature: new NearSignature({ keyType: txObj.publicKey.keyType, data: signatureBytes }) })\n    const encoded = signedTransaction.encode()\n    // Use browser-safe base64 from Uint8Array\n    return Buffer.from(encoded).toString('base64')\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    const signedTxBytes = Buffer.from(txSerialized, 'base64')\n    const signedTx = NearSignedTransaction.decode(signedTxBytes)\n    const result = await this.provider.sendTransaction(signedTx)\n    return { hash: (result as any).transaction.hash }\n  }\n}\n","import { JsonRpcProvider } from '@near-js/providers'\nimport { PublicKey as NearPublicKey, KeyPair } from '@near-js/crypto'\nimport {\n  Action as NearAction,\n  AddKey as NearAddKey,\n  AccessKey as NearAccessKey,\n  AccessKeyPermission as NearAccessKeyPermission,\n  FullAccessPermission as NearFullAccessPermission,\n  CreateAccount as NearCreateAccount,\n  Transfer as NearTransfer,\n  Transaction as NearTransaction,\n  SignedTransaction as NearSignedTransaction,\n  Signature as NearSignature,\n  encodeTransaction as nearEncodeTransaction,\n} from '@near-js/transactions'\nimport { baseDecode } from '@near-js/utils'\nimport { createHash } from 'node:crypto'\n\nexport interface EnsureDerivedAccountParams {\n  provider: JsonRpcProvider\n  controllerAccountId: string\n  controllerKeyPair: KeyPair\n  derivedAccountId: string\n  mpcPublicKey: string\n  initialDepositYocto: bigint\n}\n\nexport async function ensureDerivedAccountExists(\n  params: EnsureDerivedAccountParams\n): Promise<{ created: boolean }> {\n  const {\n    provider,\n    controllerAccountId,\n    controllerKeyPair,\n    derivedAccountId,\n    mpcPublicKey,\n    initialDepositYocto,\n  } = params\n\n  // Check if derived account exists\n  try {\n    const acc = (await provider.query(`account/${derivedAccountId}`, '')) as any\n    if (acc && typeof acc.amount === 'string') {\n      return { created: false }\n    }\n  } catch (_) {\n    // Not found -> continue to create\n  }\n\n  const controllerPubKey = controllerKeyPair.getPublicKey()\n  const accessKey = (await provider.query(\n    `access_key/${controllerAccountId}/${controllerPubKey.toString()}`,\n    ''\n  )) as any\n\n  const recentBlockHash = baseDecode(accessKey.block_hash)\n  const nextNonce = BigInt((accessKey.nonce ?? 0) + 1)\n\n  const nearMpcPubKey = NearPublicKey.fromString(mpcPublicKey)\n\n  const actions: NearAction[] = [\n    new NearAction({ createAccount: new NearCreateAccount() }),\n    new NearAction({ transfer: new NearTransfer({ deposit: initialDepositYocto }) }),\n    new NearAction({\n      addKey: new NearAddKey({\n        publicKey: nearMpcPubKey,\n        accessKey: new NearAccessKey({\n          nonce: 0n,\n          permission: new NearAccessKeyPermission({ fullAccess: new NearFullAccessPermission() }),\n        }),\n      }),\n    }),\n  ]\n\n  const tx = new NearTransaction({\n    signerId: controllerAccountId,\n    publicKey: controllerPubKey,\n    nonce: nextNonce,\n    receiverId: derivedAccountId,\n    actions,\n    blockHash: recentBlockHash,\n  })\n\n  const encoded = nearEncodeTransaction(tx)\n  const digest = createHash('sha256').update(encoded).digest()\n  const sig = controllerKeyPair.sign(digest)\n\n  const signedTx = new NearSignedTransaction({\n    transaction: tx,\n    signature: new NearSignature({ keyType: controllerPubKey.keyType, data: sig.signature }),\n  })\n\n  await provider.sendTransaction(signedTx)\n  return { created: true }\n}\n\n ","// TODO: fix signAndSend\n// import * as signAndSend from './signAndSend'\nimport * as transaction from './transaction'\nexport * from './ChainSignatureContract'\n\nconst utils = {\n  transaction,\n  // signAndSend,\n}\n\nexport { utils }\n","import {\n  type RSVSignature,\n  type MPCSignature,\n  type Ed25519Signature,\n} from '@types'\nimport { cryptography } from '@utils'\n\nexport const responseToMpcSignature = ({\n  signature,\n}: {\n  signature: MPCSignature\n}): RSVSignature | Ed25519Signature | undefined => {\n  if ('scheme' in signature && signature.scheme === 'Ed25519' && 'signature' in signature) {\n    return signature as Ed25519Signature\n  }\n  if (signature) {\n    return cryptography.toRSV(signature)\n  } else {\n    return undefined\n  }\n}\n","export const NEAR_MAX_GAS = '300000000000000'\nexport const DONT_CARE_ACCOUNT_ID = 'dontcare'\n","import { FailoverRpcProvider, JsonRpcProvider, Provider } from '@near-js/providers'\nimport { type Action, actionCreators } from '@near-js/transactions'\nimport { type FinalExecutionOutcome } from '@near-js/types'\nimport { getTransactionLastResult } from '@near-js/utils'\nimport {\n  najToUncompressedPubKeySEC1,\n  uint8ArrayToHex,\n} from '@utils/cryptography'\n\nimport {\n  type RSVSignature,\n  type UncompressedPubKeySEC1,\n  type NajPublicKey,\n  type MPCSignature,\n} from '@types'\n\nimport { NEAR_MAX_GAS } from './constants'\nimport { responseToMpcSignature } from './transaction'\nimport type { NearNetworkIds } from './types'\n\ninterface Transaction {\n  signerId?: string\n  receiverId: string\n  actions: Action[]\n}\n\nexport type HashToSign = number[] | Uint8Array\n\nexport interface SignArgs {\n  payloads: HashToSign[]\n  path: string\n  keyType: 'Eddsa' | 'Ecdsa'\n  signerAccount: {\n    accountId: string\n    signAndSendTransactions: (transactions: {\n      transactions: Transaction[]\n    }) => Promise<FinalExecutionOutcome[]>\n  }\n}\n\nexport class ChainSignatureContract {\n  private readonly contractId: string\n  private readonly networkId: NearNetworkIds\n  private readonly provider: FailoverRpcProvider\n\n  constructor({\n    contractId,\n    networkId,\n    fallbackRpcUrls,\n  }: {\n    contractId: string\n    networkId: NearNetworkIds\n    fallbackRpcUrls?: string[]\n  }) {\n    this.contractId = contractId\n    this.networkId = networkId\n\n    const rpcProviderUrls =\n      fallbackRpcUrls && fallbackRpcUrls.length > 0\n        ? fallbackRpcUrls\n        : [`https://rpc.${this.networkId}.near.org`]\n\n    this.provider = new FailoverRpcProvider(\n      rpcProviderUrls.map((url) => new JsonRpcProvider({ url }) as Provider)\n    )\n  }\n\n  getCurrentSignatureDeposit(): number {\n    return 1\n  }\n\n  async sign({\n    payloads,\n    path,\n    keyType,\n    signerAccount,\n  }: SignArgs): Promise<RSVSignature[]> {\n    const transactions = payloads.map((payload) => ({\n      signerId: signerAccount.accountId,\n      receiverId: this.contractId,\n      actions: [\n        actionCreators.functionCall(\n          'sign',\n          {\n            request: {\n              payload_v2: { [keyType]: uint8ArrayToHex(payload) },\n              path,\n              domain_id: keyType === 'Eddsa' ? 1 : 0,\n            },\n          },\n          BigInt(NEAR_MAX_GAS),\n          BigInt(1)\n        ),\n      ],\n    }))\n\n    const sentTxs = await signerAccount.signAndSendTransactions({\n      transactions,\n    })\n\n    const results = sentTxs.map((tx) =>\n      getTransactionLastResult(tx)\n    ) as MPCSignature[]\n\n    const rsvSignatures = results.map((tx) =>\n      responseToMpcSignature({ signature: tx })\n    )\n\n    return rsvSignatures as RSVSignature[]\n  }\n\n  async getPublicKey(): Promise<UncompressedPubKeySEC1> {\n    const najPubKey = await this.provider.callFunction(\n      this.contractId,\n      'public_key',\n      {}\n    )\n    return najToUncompressedPubKeySEC1(najPubKey as NajPublicKey)\n  }\n\n  async getDerivedPublicKey(args: {\n    path: string\n    predecessor: string\n    IsEd25519?: boolean\n  }): Promise<UncompressedPubKeySEC1 | `ed25519:${string}`> {\n    const najPubKey = await this.provider.callFunction(\n      this.contractId,\n      'derived_public_key',\n      {\n        path: args.path,\n        predecessor: args.predecessor,\n        domain_id: args.IsEd25519 ? 1 : 0,\n      }\n    )\n    // For Ed25519 keys, return raw format (ed25519:base58key)\n    // For secp256k1 keys, convert to uncompressed SEC1 format (04 || x || y)\n    if (args.IsEd25519) {\n      return najPubKey as `ed25519:${string}`\n    }\n    return najToUncompressedPubKeySEC1(najPubKey as NajPublicKey)\n  }\n}\n"]}